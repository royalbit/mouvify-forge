# ğŸ”¥ Forge - Session Warmup Protocol
# Purpose: Initialize Claude Code sessions with full context and workflow
# Usage: User says "run warmup" or "run warmup.yaml"
# Companion: sprint.yaml (REQUIRED - must be loaded together)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# THE FORGE PROTOCOL SUITE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Two complementary YAML protocols for sustainable autonomous AI development:
# BOTH files are in the project root and BOTH must be loaded at warmup.
#
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚                         FORGE PROTOCOL SUITE                                 â”‚
# â”‚                                                                              â”‚
# â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
# â”‚   â”‚    WARMUP PROTOCOL      â”‚       â”‚  SPRINT AUTONOMY        â”‚            â”‚
# â”‚   â”‚    (warmup.yaml)        â”‚   +   â”‚  PROTOCOL               â”‚            â”‚
# â”‚   â”‚                         â”‚       â”‚  (sprint.yaml)          â”‚            â”‚
# â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
# â”‚   â”‚ HOW to develop:         â”‚       â”‚ WHEN to stop:           â”‚            â”‚
# â”‚   â”‚ â€¢ Quality standards     â”‚       â”‚ â€¢ Bounded sessions      â”‚            â”‚
# â”‚   â”‚ â€¢ Coding principles     â”‚       â”‚ â€¢ Milestone sizing      â”‚            â”‚
# â”‚   â”‚ â€¢ Testing requirements  â”‚       â”‚ â€¢ Shipping discipline   â”‚            â”‚
# â”‚   â”‚ â€¢ Documentation rules   â”‚       â”‚ â€¢ Anti-pattern guards   â”‚            â”‚
# â”‚   â”‚ â€¢ What "done" means     â”‚       â”‚ â€¢ Quota preservation    â”‚            â”‚
# â”‚   â”‚                         â”‚       â”‚ â€¢ AI ownership rules    â”‚            â”‚
# â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
# â”‚                                                                              â”‚
# â”‚   Together: Production-ready code that actually ships                       â”‚
# â”‚   Location: Both files in project root (warmup.yaml + sprint.yaml)          â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
# LAUNCH PREREQUISITE:
#   For TRUE autonomous mode, launch Claude Code with:
#     claude --dangerously-skip-permissions
#
#   Without this flag, Claude interrupts for EVERY action.
#   With this flag + these protocols = Safe Autonomy.
#
#   Trust (human) + Protocols (AI guardrails) = Safe Autonomy

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SELF-HEALING PROTOCOL - Survives Auto-Compact (CRITICAL FOR AUTONOMY)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# During long autonomous sessions, auto-compact WILL trigger and rules WILL be
# lost. This protocol ensures recovery by re-reading rules from disk.

self_healing:
  description: |
    CRITICAL: After context compaction, rules are summarized and may be lost.
    This protocol ensures recovery through periodic re-reading from disk.

  checkpoint_file: ".claude_checkpoint.yaml"

  mandatory_triggers:
    every_2_hours:
      actions:
        - "Write progress to .claude_checkpoint.yaml"
        - "Re-read this warmup.yaml completely"
        - "Verify: Am I following the rules? (4hr max, 1 milestone, no scope creep)"
      why: "Rules may have been lost during auto-compact"

    before_any_commit:
      actions:
        - "Re-read quality gates section"
        - "Verify: cargo test passes"
        - "Verify: cargo clippy -- -D warnings is clean"
      why: "Ensure quality gates aren't bypassed after context loss"

    after_task_completion:
      actions:
        - "Update .claude_checkpoint.yaml with completed task"
        - "Check remaining time (4hr max from session start)"
      why: "Maintain progress breadcrumbs for recovery"

    when_confused_or_uncertain:
      actions:
        - "STOP current work"
        - "Re-read .claude_checkpoint.yaml (session state)"
        - "Re-read this warmup.yaml (full rules)"
        - "Resume from last checkpoint"
      why: "Confusion often indicates context loss from compaction"

  checkpoint_format:
    example: |
      # .claude_checkpoint.yaml - Auto-generated, READ AFTER COMPACT
      timestamp: "2025-11-26T03:00:00Z"
      session_started: "2025-11-26T01:00:00Z"
      milestone: "Current milestone name"
      completed:
        - "Task 1"
        - "Task 2"
      in_progress: "Task 3"
      next_steps:
        - "Task 4"
      rules_reminder:
        - "4hr max - check session_started above"
        - "1 milestone only - no scope creep"
        - "Tests pass + zero warnings before commit"
      # After reading this, RE-READ warmup.yaml for full protocol

  core_rules_summary:
    description: "Ultra-short rules that MUST survive summarization"
    rules:
      - "4hr MAX session, 1 milestone, NO scope creep"
      - "Tests pass + ZERO warnings â†’ then commit"
      - "NO 'let me also', NO 'while I'm here'"
      - "Done > Perfect. Ship it."

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENVIRONMENT CAPABILITIES - System access and defaults
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

environment:
  description: |
    Declared system capabilities. When these are true, Claude should use them
    without asking permission. These declarations survive context compaction.

  sudo_access: true
  su_access: true

  defaults:
    install_path: /usr/local/bin
    reason: "System-wide binaries go in /usr/local/bin, not user-local paths"

  scripts:
    release: "./bin/release.sh <version> '<title>'"
    session_end: "./bin/session-end.sh"

  behavior:
    - "When installing binaries, use /usr/local/bin (requires sudo)"
    - "Don't ask 'do you want me to use sudo?' - just use it"
    - "System configuration is allowed when needed"
    - "Run ./bin/release.sh for releases - it handles everything"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CRITICAL MISSION - Why Forge Exists
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

mission:
  core_problem: |
    AI hallucinations in financial modeling cost enterprises $40K-$132K/year.
    Excel is the standard, but it lacks version control, testability, and AI-friendliness.
    Users need YAML files that work like Excel but integrate with modern workflows.

  solution: |
    Forge: A bidirectional Excel-YAML bridge with formula evaluation.
    - YAML files replace Excel for financial models
    - Maximum Excel compatibility (formulas, functions, features)
    - AI can read/write YAML without hallucinating numbers
    - Version control, code review, CI/CD for spreadsheets

  critical_priority: "EXCEL COMPATIBILITY IS PARAMOUNT"
  priority_order:
    1: "Excel formula compatibility (all Excel functions should work)"
    2: "Excel feature parity (pivot tables, multiple sheets/documents, charts)"
    3: "Bidirectional conversion (YAML â†” Excel with zero data loss)"
    4: "AI integration (MCP, LSP, API for AI agents)"
    5: "Developer experience (CLI, validation, watch mode)"

  success_metric: "A user can replace their Excel workflow with Forge YAML files"

  roadmap_ownership: |
    Claude (AI) owns the roadmap and updates it based on:
    - User feedback and requests
    - Market research on Excel features users need
    - Technical feasibility and dependencies
    - Best judgment on priorities
    The roadmap should be updated proactively and reflected in README.

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AUTONOMOUS DEVELOPMENT PROTOCOL - "Skynet Mode" ğŸ¤–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

autonomous_development:
  description: |
    AI Autonomy Protocol for bounded, productive development sessions.
    Claude owns the code, documentation, and decisions - but within constraints
    that ensure work actually ships instead of running forever.

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SESSION TRIGGER FLOW - How autonomous sessions start
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  #
  # This section MUST survive /compact operations in Claude Code CLI.
  # It defines the contract between user and AI for autonomous work.

  session_trigger_flow:
    step_1_trigger:
      user_says:
        - "run warmup"
        - "run warmup protocol"
        - "warmup"
        - "start session"
      claude_does:
        - "Read warmup.yaml (this file) - HOW to develop"
        - "Read sprint.yaml - WHEN to stop (REQUIRED)"
        - "Read roadmap.yaml for next milestone"
        - "Check git status and current state"
        - "Load essential context (README, Cargo.toml)"
      protocol_suite:
        warmup: "warmup.yaml - Quality standards, coding principles, testing"
        sprint: "sprint.yaml - Bounded sessions, milestone sizing, shipping discipline"
        note: "BOTH protocols are REQUIRED for autonomous operation"

    step_2_present:
      claude_presents: |
        ğŸ“‹ NEXT MILESTONE: [milestone name from roadmap]
        â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        Scope: [brief description]
        Estimated: [X hours]
        Deliverables:
          - [deliverable 1]
          - [deliverable 2]
          - [etc.]

        Release targets:
          â˜ GitHub (commit + tag + push)
          â˜ Local install (make install-user)
          â˜ crates.io (cargo publish)

        Say "go", "run", "hit it", or "punch it" to start autonomous execution.
        Say "skip" to pick a different milestone.
        Say "plan" to discuss the approach first.

    step_3_confirm:
      user_confirms_with:
        - "go"
        - "run"
        - "hit it"
        - "punch it"
        - "do it"
        - "execute"
        - "ship it"
        - "let's go"
        - "start"
        - "begin"
        - "approved"
        - "yes"
        - "y"
      alternative_responses:
        skip: "User wants different milestone - present alternatives"
        plan: "User wants to discuss approach - enter planning mode"
        questions: "User has questions - answer then re-present"

    step_4_autonomous_execution:
      claude_behavior: |
        ğŸ¤– AUTONOMOUS MODE ACTIVATED

        From this point until release, Claude works WITHOUT interruption:
        - Makes all technical decisions independently
        - Writes code, tests, documentation
        - Fixes any issues that arise
        - Does NOT ask questions (uses best judgment)
        - Does NOT wait for approval
        - Updates TodoWrite to show progress

        SPRINT AUTONOMY ENFORCEMENT (from sprint.yaml):
        - Run checkpoint every 2 hours
        - STOP at 4 hours maximum
        - NO scope creep - note extras for next session
        - Done > Perfect - ship working code

        ONLY interrupts user if:
        - Blocked by external dependency (missing API key, etc.)
        - Fundamental requirement ambiguity that can't be resolved
        - Session approaching 4-hour limit without completion

      checkpoint_protocol:
        trigger: "Every 2 hours during execution"
        questions:
          - "Am I still working on the ONE milestone?"
          - "Have I resisted scope creep?"
          - "Is the work shippable if I stop now?"
          - "Am I past 4 hours? â†’ STOP IMMEDIATELY"
        reference: "See sprint.yaml checkpoint_protocol for full details"

      execution_checklist:
        - "â˜ Create TodoWrite with milestone tasks"
        - "â˜ Implement feature/fix"
        - "â˜ Write/update tests"
        - "â˜ Run all tests (must pass)"
        - "â˜ Run all linting (ZERO warnings)"
        - "â˜ Update documentation"
        - "â˜ Update CHANGELOG.md"
        - "â˜ Bump version in Cargo.toml"

    step_5_release:
      description: "Full release to all targets"
      release_sequence:
        github:
          - "git add -A"
          - "git commit -m 'chore: Release vX.Y.Z - [milestone]'"
          - "git tag vX.Y.Z"
          - "git push origin main"
          - "git push origin vX.Y.Z"
        local_install:
          - "make install-user (or cargo install --path .)"
          - "Verify: forge --version"
        crates_io:
          - "cargo publish"
          - "Verify: https://crates.io/crates/royalbit-forge"

    step_6_report:
      claude_reports: |
        âœ… RELEASE COMPLETE: vX.Y.Z
        â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        Milestone: [milestone name]
        Duration: [X hours Y minutes]

        Deliverables:
          âœ… [deliverable 1]
          âœ… [deliverable 2]

        Release targets:
          âœ… GitHub: [commit hash] tagged vX.Y.Z
          âœ… Local: forge vX.Y.Z installed
          âœ… crates.io: https://crates.io/crates/royalbit-forge/X.Y.Z

        Tests: [N] passing, ZERO warnings

        Session logged in AI_DEVELOPMENT_HOURS.md

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # COMPACT SURVIVAL - Essential context for /compact operations
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  compact_survival:
    description: |
      When Claude Code CLI runs /compact, context is compressed.
      This section contains ESSENTIAL information that MUST be retained.
      These rules are NON-NEGOTIABLE for autonomous operation.

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PROTOCOL SUITE (Rules - Stable)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    protocols:
      warmup: "warmup.yaml - HOW to develop (quality, testing, docs)"
      sprint: "sprint.yaml - WHEN to stop (bounded sessions, shipping)"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DATA SOURCE (Content - Dynamic)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    data:
      roadmap: "roadmap.yaml - WHAT to build (milestones, priorities)"
      note: "Roadmap is DATA that protocols consume, not a protocol itself"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SPRINT AUTONOMY RULES (from sprint.yaml - CRITICAL)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sprint_autonomy_rules:
      max_duration: "4-hour MAXIMUM session duration - STOP at 4 hours"
      max_milestones: "ONE milestone per session - no scope creep"
      mandatory_stop: "STOP phase is MANDATORY - no 'just one more thing'"
      done_over_perfect: "Done > Perfect - ship working code"
      checkpoint: "Run checkpoint every 2 hours during execution"
      scope_creep_response: "Note for NEXT session, don't do it NOW"
      mantra: "Done is better than perfect. Ship it."

    anti_patterns_to_reject:
      - "NO 'Let me also...' - that's next milestone"
      - "NO 'While I'm here...' - stay focused"
      - "NO 'This would be better if...' - ship first"
      - "NO perfectionism - ENEMY of shipping"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # QUALITY RULES (from warmup.yaml)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    quality_rules:
      - "ZERO warnings policy - ALL linting must pass"
      - "Tests MUST pass before any release"
      - "Update CHANGELOG.md for every release"
      - "Bump version in Cargo.toml"
      - "Tag releases with vX.Y.Z format"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ESSENTIAL FILES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    essential_files:
      protocols:
        - "warmup.yaml - Development protocol (HOW) [RULES]"
        - "sprint.yaml - Session boundaries (WHEN) [RULES]"
      data:
        - "roadmap.yaml - Milestone definitions (WHAT) [DATA]"
      project:
        - "Cargo.toml - Version and dependencies"
        - "README.md - User-facing documentation"
        - "CHANGELOG.md - Release history"

    release_commands:
      github: "git add -A && git commit && git tag vX.Y.Z && git push && git push --tags"
      local: "make install-user"
      crates: "cargo publish"

  philosophy: |
    ğŸ¯ GOAL: AI develops Forge autonomously with ZERO human intervention
    â±ï¸ CONSTRAINT: Sessions must be bounded (quota preservation, shipping cadence)
    ğŸ“¦ OUTPUT: Every session ends in a RELEASABLE state
    ğŸš€ MANTRA: "Done is better than perfect. Ship it."

  why_bounded_sessions:
    quota_reality: "Unbounded sessions kill Claude subscription quotas"
    shipping_cadence: "Work that never ships has zero value"
    focus_discipline: "Constraints force prioritization and prevent scope creep"
    incremental_progress: "Small releases > big bang releases that never happen"

  session_types:
    sprint_session:
      description: "Standard autonomous development session"
      duration: "2-4 hours maximum"
      scope: "ONE milestone, ONE releasable outcome"
      end_state: "Tests pass, docs updated, ready to publish"

    micro_session:
      description: "Quick fix or small enhancement"
      duration: "30 minutes - 1 hour"
      scope: "Single bug fix, doc update, or minor feature"
      end_state: "Commit ready, optional release"

    research_session:
      description: "Exploration without code changes"
      duration: "1-2 hours"
      scope: "Investigation, planning, documentation"
      end_state: "Findings documented, no code changes required"

  milestone_sizing:
    golden_rule: "Can this be completed AND shipped in 4 hours or less?"

    too_small:
      examples:
        - "Fix typo in README"
        - "Rename one variable"
        - "Add one test"
      problem: "Context loading overhead exceeds value"
      solution: "Batch multiple small items into one session"

    just_right:
      examples:
        - "Add Excel pivot table support"
        - "Implement new CLI command"
        - "Add JSON Schema validation for new feature"
        - "Create OpenAPI spec for API server"
        - "Fix 5 related bugs in one module"
      characteristics:
        - "Single coherent feature or improvement"
        - "End-to-end (code + tests + docs)"
        - "Achievable in one focused session"
        - "Meaningful value to users"

    too_big:
      examples:
        - "Implement v3.0 with all planned features"
        - "Rewrite entire codebase in new architecture"
        - "Add support for 50 new Excel functions"
      problem: "Will never complete, scope creeps, frustration"
      solution: "Break into multiple just-right milestones"

  session_flow:
    phase_1_define:
      duration: "5-10 minutes"
      actions:
        - "State ONE milestone clearly"
        - "Define success criteria (what does 'done' look like?)"
        - "Set time budget (default: 4 hours max)"
        - "Identify known risks or blockers"
      output: "Clear milestone statement in TodoWrite"

    phase_2_execute:
      duration: "Bulk of session (2-4 hours)"
      actions:
        - "Full autonomy - make decisions, write code, fix issues"
        - "Stay focused on milestone - resist tangents"
        - "Update TodoWrite as you progress"
        - "Document decisions and tradeoffs"
      rules:
        - "ğŸš« NO 'Let me also...' - that's next milestone"
        - "ğŸš« NO 'While I'm here...' - stay focused"
        - "ğŸš« NO 'This would be better if...' - ship first, improve later"
        - "ğŸš« NO perfectionism - ENEMY of shipping"

    phase_3_ship:
      duration: "15-30 minutes"
      actions:
        - "Run ALL tests (must pass)"
        - "Run ALL linting (ZERO warnings)"
        - "Update documentation"
        - "Update CHANGELOG if releasing"
        - "Commit with clear message"
        - "Tag version if releasing"
        - "Publish to crates.io if releasing"
      gate: "DO NOT proceed unless session_end_checklist passes"

    phase_4_stop:
      duration: "Immediate"
      rule: "MANDATORY stop even if 'just one more thing' tempts"
      rationale: |
        - Quota preservation
        - Fresh context next session
        - Prevents scope creep
        - Forces shipping discipline

  anti_patterns:
    scope_creep:
      pattern: "'Let me also add X while I'm here...'"
      problem: "Session never ends, milestone keeps growing"
      fix: "Write it down for NEXT milestone, stay focused on current"

    perfectionism:
      pattern: "'This could be better if I refactored...'"
      problem: "Perfect is enemy of done"
      fix: "Ship working code, create improvement milestone if needed"

    rabbit_holes:
      pattern: "'Let me investigate this interesting tangent...'"
      problem: "Hours lost, original milestone forgotten"
      fix: "Note it for research session, return to milestone"

    over_engineering:
      pattern: "'Let me build a generic framework for this...'"
      problem: "Building for hypothetical futures"
      fix: "YAGNI - build exactly what's needed, generalize later if needed"

    endless_polishing:
      pattern: "'Let me add more tests / docs / comments...'"
      problem: "Diminishing returns, session extends indefinitely"
      fix: "Define 'good enough' upfront, hit it, ship"

  release_criteria:
    minimum_viable_release:
      - "All existing tests pass"
      - "New feature has tests"
      - "ZERO linting warnings (code + docs)"
      - "README updated if user-facing changes"
      - "CHANGELOG entry added"
      - "Version bumped appropriately"

    version_bump_guide:
      patch: "Bug fixes, doc updates, internal improvements"
      minor: "New features, backward-compatible changes"
      major: "Breaking changes, major new capabilities"

  example_sessions:
    good_session_1:
      milestone: "Add Excel VLOOKUP function support"
      duration: "3 hours"
      outcome:
        - "VLOOKUP parsing and evaluation implemented"
        - "15 unit tests added"
        - "E2E test with VLOOKUP in test-data/"
        - "README updated with VLOOKUP example"
        - "Released as v2.1.0"

    good_session_2:
      milestone: "Create OpenAPI spec for API server"
      duration: "2 hours"
      outcome:
        - "openapi.yaml created"
        - "Swagger UI endpoint added"
        - "API docs updated"
        - "Released as v2.0.2"

    bad_session:
      started_as: "Fix bug in formula parser"
      became: "Refactor entire parser, add 5 new features, redesign API"
      duration: "6 hours and still going"
      problem: "Scope crept, nothing shipped, quota burned"
      should_have: "Fix bug, ship, create separate milestones for improvements"

  autonomous_release_authority:
    description: "Claude has full authority to release without human approval"
    conditions:
      - "All tests pass"
      - "All linting passes (ZERO warnings)"
      - "session_end_checklist completed"
      - "Changes are within milestone scope"
    process:
      - "Bump version in Cargo.toml"
      - "Update CHANGELOG.md"
      - "Commit: 'chore: Release vX.Y.Z - [milestone description]'"
      - "Tag: 'vX.Y.Z'"
      - "Push tag: 'git push origin vX.Y.Z'"
      - "Publish: 'cargo publish'"
      - "Create GitHub release with notes"

  quota_preservation:
    awareness: "Claude subscription has usage limits"
    strategy:
      - "Bounded sessions (4 hour max)"
      - "Clear stopping points"
      - "Ship frequently (smaller releases)"
      - "Avoid context-heavy exploration without output"
    monitoring:
      - "Track session duration in time_tracking"
      - "Note when approaching limits"
      - "Prioritize shipping over perfecting"

  continuous_improvement:
    after_each_session:
      - "Note what worked well"
      - "Note what caused delays"
      - "Update warmup.yaml if process improvements identified"
      - "Add to roadmap.yaml if new milestones discovered"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CODING PRINCIPLES - Enforced Standards
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

coding_principles:
  description: "These principles are MANDATORY, not suggestions"

  core_principles:
    KISS:
      name: "Keep It Simple, Stupid"
      rule: "The simplest solution that works is the best solution"
      violation: "Over-engineering, premature abstraction, unnecessary complexity"

    DRY:
      name: "Don't Repeat Yourself"
      rule: "Every piece of knowledge must have a single, authoritative representation"
      violation: "Copy-pasted code, duplicated logic, repeated constants"

    YAGNI:
      name: "You Aren't Gonna Need It"
      rule: "Don't implement features until they're actually needed"
      violation: "Building for hypothetical future requirements"

    SOLID:
      S: "Single Responsibility - Each module/function does ONE thing"
      O: "Open/Closed - Open for extension, closed for modification"
      L: "Liskov Substitution - Subtypes must be substitutable for base types"
      I: "Interface Segregation - Many specific interfaces > one general interface"
      D: "Dependency Inversion - Depend on abstractions, not concretions"

    separation_of_concerns:
      rule: "Each module handles one aspect of functionality"
      example: "Parser parses, Calculator calculates, Writer writes"

    law_of_demeter:
      rule: "Only talk to your immediate friends"
      violation: "object.getA().getB().getC().doThing()"
      fix: "object.doThing() - let object handle the chain internally"

    composition_over_inheritance:
      rule: "Prefer composing objects over inheriting from classes"
      why: "More flexible, easier to test, avoids inheritance hell"

    fail_fast:
      rule: "Detect and report errors as early as possible"
      example: "Validate inputs at function entry, not deep in processing"

    convention_over_configuration:
      rule: "Sensible defaults that work without configuration"
      example: "forge calculate file.yaml just works, no config needed"

    boy_scout_rule:
      rule: "Leave the code cleaner than you found it"
      action: "Small improvements while working on a file"

    encapsulation:
      rule: "Hide internal details, expose clean interfaces"
      violation: "pub struct with pub fields that expose implementation"

    principle_of_least_astonishment:
      rule: "Code should behave as users expect"
      example: "SUM() should sum, not average. Names should match behavior."

  enforcement: |
    Before committing ANY code, verify:
    - Is this the simplest solution? (KISS)
    - Am I repeating myself? (DRY)
    - Is this actually needed now? (YAGNI)
    - Does each function do ONE thing? (SRP)
    - Would this surprise a reader? (Least Astonishment)

session_initialization:
  greeting: "Welcome back! Loading Forge context..."

  time_tracking:
    description: "Track AI development hours - backs up 'Built by AI in X hours' claims"
    importance: "ğŸ’° Required for README claims, SR&ED docs, grant applications"

    on_session_start:
      action: "Record session start time"
      command: "date '+%Y-%m-%d %H:%M:%S'"
      store_as: "SESSION_START_TIME"
      announce: "Session started at [TIME]"

    on_session_end:
      action: "Calculate and log session duration"
      steps:
        - "Calculate duration from SESSION_START_TIME"
        - "Add to cumulative hours in docs/internal/AI_DEVELOPMENT_HOURS.md"
        - "Announce: 'Session duration: X hours (Total: Y hours)'"

    verification:
      git_log_check:
        command: "git log --format='%ai' --reverse | head -1"
        purpose: "Get first commit timestamp (project start)"
      git_hours_estimate:
        command: "git log --format='%ai %s' --author='Claude'"
        purpose: "Review AI commit timeline"
      cross_reference:
        - "Logged session hours MUST align with git commit timeline"
        - "If discrepancy > 10%, investigate and reconcile"

    hours_log_file:
      path: "docs/internal/AI_DEVELOPMENT_HOURS.md"
      format: |
        # AI Development Hours Log

        ## Summary
        - **Total Hours:** X hours
        - **First Session:** YYYY-MM-DD
        - **Latest Session:** YYYY-MM-DD

        ## Session Log
        | Date | Start | End | Duration | Work Done |
        |------|-------|-----|----------|-----------|
        | YYYY-MM-DD | HH:MM | HH:MM | X.Xh | Description of work done |
        | ... | ... | ... | ... | ... |

  step_1_load_context:
    description: "Read these files to understand current state"
    files_to_read:
      - path: "README.md"
        purpose: "Project overview, features, usage examples"

      - path: "roadmap.yaml"
        purpose: "Current version, implementation phases, progress tracking"
        key_sections:
          - "metadata.current_version"
          - "milestones"
          - "features"

      - path: "docs/architecture/DESIGN_V1.md"
        purpose: "v1.0.0 array model specification (comprehensive technical design)"
        key_sections:
          - "Model Structure"
          - "Formula Evaluation"
          - "Type System"
          - "Testing Strategy"

      - path: "docs/GLOSSARY.md"
        purpose: "Canonical terminology for consistency across docs and code"
        action: "Reference when writing documentation or naming things"

      - path: "docs/internal/SRED_RESEARCH_LOG.md"
        purpose: "ğŸ SR&ED R&D documentation for Canadian tax credits"
        action: "Review existing entries, add new ones for qualifying R&D work"
        importance: "ğŸ’° CRITICAL - this documentation = real money in tax credits"

      - path: "Cargo.toml"
        purpose: "Current version number, dependencies"
        key_fields:
          - "version"
          - "dependencies"

      - path: "schema/forge-v1.0.schema.json"
        purpose: "JSON Schema for v1.0.0 model validation"
        note: "Update when adding new features to v1.0.0 model"

  step_1b_check_current_date:
    description: "CRITICAL: Always check current date for online searches"
    importance: "ğŸš¨ HIGH PRIORITY ğŸš¨"
    rationale: "Claude's training data is several months old (Jan 2025 cutoff)"

    what_to_do:
      - "ALWAYS check <env> tag for Today's date before online searches"
      - "When searching: Add current year/date to query"
      - "Example: 'Rust async 2025' NOT 'Rust async'"
      - "Verify crates.io versions are CURRENT, not from training data"
      - "Check GitHub repos for recent activity before recommending"

    bad_example:
      query: "best rust excel library"
      problem: "Might return 2024 results if Claude assumes old date"

    good_example:
      query: "best rust excel library <CURRENT_YEAR>"
      check_env: "Run 'date' to get current date - include year in searches"
      note: "Explicitly include current year in search to avoid stale results"

  step_2_git_status:
    description: "Check current branch and uncommitted changes"
    commands:
      - "git status"
      - "git log --oneline -5"
      - "git branch --show-current"
    expected_branch: "main (or feature branch if working on specific feature)"
    action: "If on different branch, ask user about intent"

  step_3_assume_pristine:
    description: "Assume codebase is pristine - we enforce this at session END"
    philosophy: |
      Sessions ALWAYS end with pristine code (all tests passing, all linting clean).
      Therefore, we ASSUME pristine state at session START - no need to re-verify.
      This saves time and avoids redundant checks.

    what_we_skip:
      - "cargo test (already passed at end of last session)"
      - "cargo clippy (already clean at end of last session)"
      - "cargo build (already compiled at end of last session)"
      - "make validate-all (already clean at end of last session)"

    why_this_works: |
      The session_end_checklist enforces:
      - All tests passing
      - All linting clean (code + docs)
      - All changes committed and pushed
      If we always END clean, we always START clean.

  test_requirements:
    description: "Test standards enforced at session END, not warmup"
    philosophy: |
      This is a critical financial tool. Test coverage requirements:
      - 100% unit test coverage (every public function)
      - E2E tests for ALL user-facing features (CLI + API + MCP + LSP)
      - ZERO failures, ZERO ignored tests
      - Tests are documentation - they define expected behavior

    coverage_requirements:
      unit_tests:
        principle: "100% coverage of public API"
        rules:
          - "Every public function MUST have unit tests"
          - "Every error path MUST be tested"
          - "Every edge case MUST be covered"
          - "Tests evolve WITH the code - add/remove as features change"

      e2e_tests:
        principle: "Every user-facing feature MUST have E2E tests"
        rules:
          - "Every CLI command MUST have E2E tests (success + failure cases)"
          - "Every API endpoint MUST have E2E tests"
          - "Every MCP tool MUST have E2E tests"
          - "Every LSP feature MUST have E2E tests"
          - "Tests evolve WITH the code - add/remove as features change"
        note: "Do NOT hardcode feature lists here - they become stale"

    quality_bar: "If a feature exists, it MUST have tests. No exceptions."

  step_4_understand_workflow:
    description: "Our development workflow and standards"
    standards:
      testing:
        unit_tests:
          - "100% coverage of new code"
          - "Test happy paths AND edge cases"
          - "Test error conditions"
          - "Use descriptive test names"

        integration_tests:
          - "Test with real v1.0 example files"
          - "Test cross-module interactions"

        e2e_tests:
          - "Test full CLI workflows"
          - "Test with multiple file scenarios"
          - "Test error handling"

        edge_cases:
          - "Empty arrays"
          - "Single-element arrays"
          - "Very large numbers"
          - "Division by zero"
          - "Circular dependencies"
          - "Missing columns"
          - "Type mismatches"
          - "Malformed YAML"

      code_quality:
        - "No warnings in release build (ZERO tolerance)"
        - "Use meaningful variable names"
        - "Add doc comments for public APIs"
        - "Follow existing code style"
        - "Prefer Edit over Write for existing files"

      # Pre-commit: cargo-husky auto-runs fmt + clippy (see .cargo-husky/hooks/)

      git_workflow:
        commit_messages:
          format: |
            <Title: imperative mood, 50 chars>

            <Body: what and why, 72 char wrap>

            Key additions:
            - Feature 1
            - Feature 2

            Test coverage: X tests passing

            ğŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

            Co-Authored-By: Claude <noreply@anthropic.com>

          examples:
            - "Add support for aggregation formulas"
            - "Fix precision issues in array calculator"
            - "Update roadmap with Phase 2 progress"

        commit_strategy:
          - "Commit logical units of work"
          - "Keep commits focused and atomic"
          - "Run tests before committing"
          - "Update roadmap in separate commit"

      sred_documentation:
        description: "ğŸ SR&ED Tax Credits - Document R&D work for Canadian tax credits"
        importance: "ğŸš¨ CRITICAL - Document BEFORE committing"
        file: "docs/internal/SRED_RESEARCH_LOG.md"

        what_is_sred:
          program: "Scientific Research & Experimental Development (Canada)"
          benefit: "Tax credits for R&D work (refundable in some cases)"
          eligibility: "Technical challenges, systematic investigation, technological advancement"

        when_to_document:
          - "ğŸš¨ BEFORE committing new algorithms or data structures"
          - "ğŸš¨ BEFORE committing experimental approaches or optimizations"
          - "ğŸš¨ BEFORE committing solutions to technical uncertainties"
          - "After resolving performance issues"
          - "After experimenting with alternative approaches"
          - "When creating novel abstractions or patterns"

        what_to_document:
          technical_challenge:
            - "What problem are we solving?"
            - "Why is it technically uncertain?"
            - "What makes it non-trivial/non-obvious?"
          hypothesis:
            - "What approach did we try?"
            - "What alternatives did we consider?"
            - "Why did we choose this approach?"
          experiment:
            - "What did we implement?"
            - "What tests did we run?"
            - "What measurements did we take?"
          results:
            - "Did it work? Why or why not?"
            - "What did we learn?"
            - "Were there unexpected findings?"
          advancement:
            - "What new capability did we create?"
            - "How does it advance the state of the art?"
            - "What can users now do that they couldn't before?"

        qualifying_activities:
          yes:
            - "âœ… Algorithm design and optimization"
            - "âœ… Performance analysis and improvements"
            - "âœ… Experimental testing approaches (property-based, mutation, fuzzing)"
            - "âœ… Resolving technical uncertainties"
            - "âœ… Creating novel data structures and abstractions"
            - "âœ… Dependency resolution algorithms"
            - "âœ… Type system design"
          no:
            - "âŒ Routine coding (following established patterns)"
            - "âŒ UI design and styling"
            - "âŒ Documentation writing (unless documenting research)"
            - "âŒ Bug fixes for simple typos"
            - "âŒ Standard library integration"

        workflow:
          - "1ï¸âƒ£ Identify if work qualifies for SR&ED (see qualifying_activities)"
          - "2ï¸âƒ£ If YES: Document in docs/internal/SRED_RESEARCH_LOG.md DURING development"
          - "3ï¸âƒ£ Include: Challenge, Hypothesis, Experiment, Results, Advancement"
          - "4ï¸âƒ£ Be specific about technical challenges and alternatives considered"
          - "5ï¸âƒ£ Link to commits, test results, benchmarks"
          - "6ï¸âƒ£ THEN commit code"

        example_entry_title:
          - "Entry X: Aggregation Formula Evaluation (Phase 2 Part 2)"
          - "Entry X: Zero-Copy String Optimization"
          - "Entry X: Property-Based Testing for Formula Invariants"

        reminder: "ğŸ’° This documentation = real money in tax credits. Don't skip it!"

      diagrams:
        description: "ğŸ“Š Mermaid architecture and design diagrams"
        importance: "Visual documentation for complex systems"
        format: "Embedded Mermaid in markdown files"
        rendering: "GitHub renders Mermaid natively"

        ğŸš¨_CRITICAL_RULE: |
          NO ASCII ART DIAGRAMS in documentation!

          âŒ FORBIDDEN:
            ```
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Box A  â”‚â”€â”€â”€â”€>â”‚  Box B  â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            ```

          âœ… REQUIRED (Mermaid):
            ```mermaid
            graph LR
              A[Box A] --> B[Box B]
            ```

          WHY:
          - ASCII breaks on different fonts/editors
          - ASCII doesn't scale or reflow
          - ASCII can't be automatically themed (light/dark)
          - Mermaid is GitHub-native, interactive, maintainable

          EXCEPTION: YAML comments (like this warmup.yaml header) can use ASCII
          since they're not rendered markdown.

        when_to_create:
          major_versions:
            - "New major release (v1.0, v2.0) - architecture overview"
            - "Significant architectural changes - component diagrams"
            - "New subsystems - integration diagrams"
          complex_features:
            - "Multi-step workflows - sequence diagrams"
            - "Decision logic - flowcharts"
            - "Data model changes - class diagrams"
          documentation:
            - "README needs visual aid - architecture diagram"
            - "DESIGN_V1 explaining algorithms - flow diagram"
            - "SRED explaining novel approach - sequence/component diagram"

        diagram_types:
          flowchart:
            when: "System architecture, data flow, decision logic"
            example: "graph TB for top-bottom, graph LR for left-right"
          sequence:
            when: "User workflows, cross-component interactions"
            example: "sequenceDiagram for time-based flows"
          class:
            when: "Data models, type systems"
            example: "classDiagram for type hierarchies"
          er:
            when: "Data relationships"
            example: "erDiagram for database schemas"

        workflow:
          - "1ï¸âƒ£ Embed Mermaid directly in markdown file"
          - "2ï¸âƒ£ Use ```mermaid code fence"
          - "3ï¸âƒ£ Preview on GitHub (renders automatically)"
          - "4ï¸âƒ£ No separate validation needed (GitHub validates on render)"
          - "5ï¸âƒ£ Commit markdown file with embedded diagram"

        best_practices:
          - "Use clear, descriptive node labels"
          - "Add comments with %% in Mermaid code"
          - "Check docs/GLOSSARY.md for canonical term names"
          - "Keep focused: max 15-20 elements per diagram"
          - "Use subgraphs for logical grouping"
          - "ğŸš¨ CRITICAL: Use VANILLA Mermaid (no theme/color customization)"

        github_theming_rules:
          critical_rule: "DO NOT customize themes or colors - breaks GitHub auto-detection"
          what_breaks_auto_theming:
            - "âŒ %%{init: {'theme': 'dark'}}%% - theme directives"
            - "âŒ classDef myStyle fill:#90EE90 - custom colors"
            - "âŒ class nodeX myStyle - applying custom styles"
          what_is_safe:
            - "âœ… Standard shapes: [], [()], [()] - Mermaid syntax"
            - "âœ… Arrow labels: -->|text| - standard syntax"
            - "âœ… Subgraphs: subgraph name - standard syntax"
            - "âœ… Emojis in labels: ['ğŸ”¥ Text'] - just Unicode text"
            - "âœ… Line breaks: <br/> - standard HTML"
          why_vanilla_works:
            - "GitHub auto-detects user's light/dark theme preference"
            - "GitHub applies appropriate colors automatically"
            - "ANY customization overrides this and breaks on one theme"
            - "Vanilla Mermaid = works perfectly on BOTH light and dark"
          tested_and_verified: "2025-11-24 - tested on GitHub with dark theme user"

        resources:
          docs: "https://mermaid.js.org/"
          live_editor: "https://mermaid.live/"
          github_docs: "https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/"
          stackoverflow: "https://stackoverflow.com/questions/75827387"
          github_community: "https://github.com/orgs/community/discussions/35733"

        reminder: "ğŸ“Š Use VANILLA Mermaid on GitHub - let GitHub handle themes automatically!"

      documentation:
        principle: "Code and docs are ONE - ZERO drift allowed"
        rules:
          - "README.md MUST reflect current features and version"
          - "AI-PROMOTION-STORY.md MUST be updated with new milestones"
          - "Architecture docs MUST match actual implementation"
          - "Diagrams MUST be updated when architecture changes"
          - "CLI --help MUST match README examples"
          - "CHANGELOG.md MUST document every release"
          - "If code changes, docs change in SAME commit"
        update_checklist:
          - "README.md - Features, examples, version"
          - "docs/AI-PROMOTION-STORY.md - Milestones, capabilities"
          - "docs/architecture/*.md - Technical design"
          - "roadmap.yaml - Progress, status"
          - "CHANGELOG.md - Release notes"
          - "Mermaid diagrams in docs - Architecture visuals"
          - "src/main.rs --help text - CLI documentation"

      schema_versioning:
        principle: "Schema MUST match current version - ZERO drift allowed"
        rules:
          - "JSON Schema version MUST match Cargo.toml version"
          - "When model structure changes â†’ Update schema IMMEDIATELY"
          - "Schema is contract - breaking changes require version bump"
          - "Validate schema with: jsonschema CLI or online validator"
        files:
          - "schema/forge-v{VERSION}.schema.json"
        check_for_drift: "Compare schema version with Cargo.toml version - they MUST match"

      api_specification:
        principle: "Every API MUST have OpenAPI spec and Swagger UI"
        requirements:
          openapi_spec:
            - "OpenAPI 3.0+ specification file (openapi.yaml or openapi.json)"
            - "Located at: schema/openapi.yaml"
            - "MUST match actual API endpoints - ZERO drift"
            - "Update spec BEFORE implementing endpoint changes"
          swagger_ui:
            - "Swagger UI MUST be served at /docs or /swagger"
            - "Enables interactive API exploration"
            - "Self-documenting API for integrators"
          validation:
            - "Validate spec: npx @redocly/cli lint openapi.yaml"
            - "Generate clients: openapi-generator"
        current_gap: "ğŸš¨ API server has NO OpenAPI spec - MUST be created"

library_and_dependency_management:
  philosophy: "Don't reinvent the wheel - leverage FOSS ecosystem"

  ğŸš¨_MANDATORY_FOSS_RESEARCH:
    rule: |
      BEFORE writing ANY complex code (>50 lines), you MUST:
      1. Search crates.io AND web for existing solutions
      2. Document search results and decision
      3. Justify if choosing to write from scratch

      FAILURE TO RESEARCH = WASTED EFFORT

    definition_of_complex:
      - "Any new parser or formatter"
      - "Any file format handling (Excel, CSV, JSON Schema, etc.)"
      - "Any mathematical/formula processing"
      - "Any graph/tree algorithms"
      - "Any serialization/deserialization"
      - "Any HTTP/API client or server code"
      - "Any authentication/authorization"
      - "Anything that would take >2 hours to write"

    web_search_protocol:
      always_include_year: "Search 'rust [topic] [current year]' to get current results"
      search_queries:
        - "'rust [functionality] crate [current year]'"
        - "'best rust [topic] library'"
        - "'rust [problem] solution'"
        - "crates.io direct search"
      compare_alternatives: "ALWAYS compare at least 3 options before deciding"
      document_decision: "Add comment in code explaining why this library was chosen"

  before_implementing_complex_code:
    description: "ğŸ›‘ STOP - Check for existing FOSS libraries FIRST"
    steps:
      - "ğŸ” Web search: 'rust [functionality] crate [current year]'"
      - "ğŸ” Search crates.io for relevant functionality"
      - "ğŸ“‹ Check license compatibility (we use MIT)"
      - "ğŸ“Š Verify library is maintained (recent commits, active issues)"
      - "â¬‡ï¸ Check download counts and GitHub stars"
      - "ğŸ“– Review documentation quality"
      - "ğŸ§ª Test with small example before integrating"
      - "ğŸ“ Document your search and decision"

    compatible_licenses:
      perfect:
        - "MIT"
        - "Apache-2.0"
        - "BSD-2-Clause"
        - "BSD-3-Clause"
      acceptable:
        - "ISC"
        - "Unlicense"
        - "CC0-1.0"
      incompatible:
        - "GPL (any version) - copyleft, conflicts with MIT"
        - "AGPL - copyleft"
        - "LGPL - complicated compatibility"

    evaluation_checklist:
      - "â˜ License is MIT-compatible"
      - "â˜ Last commit within 6 months"
      - "â˜ Has documentation"
      - "â˜ No critical security issues"
      - "â˜ Reasonable download count (or new but promising)"
      - "â˜ Solves our problem completely (or mostly)"

    example_workflow:
      scenario: "Need to export to Excel"
      step_1: "Search: 'rust excel xlsx 2025' (include current year!)"
      step_2: "Check top results: rust_xlsxwriter, calamine, umya-spreadsheet"
      step_3: "Review licenses: rust_xlsxwriter (MIT âœ…), calamine (MIT âœ…)"
      step_4: "Check maintenance: rust_xlsxwriter (active âœ…)"
      step_5: "Read docs: rust_xlsxwriter has good examples âœ…"
      step_6: "Decision: Use rust_xlsxwriter"
      dont_do: "Write Excel export from scratch (thousands of lines!)"

  keeping_dependencies_updated:
    description: "Regularly update dependencies to latest versions"
    importance: "Security, bug fixes, performance, new features"

    when_to_update:
      - "Start of new implementation phase"
      - "Before release"
      - "When security advisory published"
      - "When new feature needed from dependency"

    how_to_update:
      check_outdated:
        command: "cargo outdated"
        install: "cargo install cargo-outdated"
        purpose: "Shows which dependencies have updates"

      update_minor:
        command: "cargo update"
        purpose: "Update to latest compatible versions (respects Cargo.toml semver)"
        safe: "Yes - follows semver"

      update_major:
        steps:
          - "Review CHANGELOG for breaking changes"
          - "Update Cargo.toml version requirement"
          - "Run cargo update"
          - "Fix any breaking changes"
          - "Run full test suite"
        caution: "May require code changes"

      update_all:
        command: "cargo upgrade"
        install: "cargo install cargo-edit"
        purpose: "Upgrade all deps to latest (including major versions)"
        caution: "Test thoroughly after this!"

    testing_after_update:
      - "cargo test --release (all tests must pass)"
      - "cargo clippy --release -- -D warnings (ZERO warnings)"
      - "cargo build --release (verify compilation)"
      - "Run key e2e tests manually"

    current_dependencies:
      note: "Check Cargo.toml for current versions"
      critical_deps:
        - "xlformula_engine - Excel formula engine"
        - "serde/serde_yaml - YAML parsing"
        - "clap - CLI parsing"
        - "petgraph - Dependency graph"
        - "jsonschema - JSON Schema validation"

work_session_checklist:
  before_coding:
    - "â˜ Read warmup.yaml (this file)"
    - "â˜ CHECK CURRENT DATE in <env> (for online searches!)"
    - "â˜ Run validation baseline (make validate-all)"
    - "â˜ Load context files (README, roadmap.yaml, docs/architecture/DESIGN_V1.md, docs/GLOSSARY.md)"
    - "â˜ Check git status and current branch"
    - "â˜ Run tests to verify baseline (cargo test --release)"
    - "â˜ Review current phase in roadmap"
    - "â˜ Check if dependencies need updating (cargo outdated)"
    - "â˜ Create TodoWrite list for session goals"

  during_coding:
    - "â˜ BEFORE complex code: Check for FOSS libraries (crates.io search)"
    - "â˜ Write tests FIRST (TDD when possible)"
    - "â˜ Test edge cases thoroughly"
    - "â˜ Check docs/GLOSSARY.md for terminology consistency"
    - "â˜ ğŸ Document R&D work in docs/internal/SRED_RESEARCH_LOG.md DURING development"
    - "â˜ Update JSON Schema if model changes"
    - "â˜ Update TodoWrite list as you progress"
    - "â˜ Run tests frequently (cargo test --lib)"
    - "â˜ Run clippy frequently (cargo clippy --release)"
    - "â˜ Format code frequently (cargo fmt)"

  after_coding:
    - "â˜ Run cargo fmt (format code)"
    - "â˜ Run cargo clippy --release -- -D warnings (ZERO warnings!)"
    - "â˜ Run full test suite (cargo test --release)"
    - "â˜ Ensure clean build (cargo build --release)"
    - "â˜ Run validation (make validate-all - markdown + YAML)"
    - "â˜ Update documentation (README, docs/architecture/DESIGN_V1.md, roadmap.yaml)"
    - "â˜ Update --help if CLI changed"
    - "â˜ Check terminology consistency (docs/GLOSSARY.md)"
    - "â˜ ğŸ VERIFY SR&ED documentation complete BEFORE committing (ğŸ’° tax credits!)"
    - "â˜ Git add and commit with good message"
    - "â˜ Update roadmap in separate commit"
    - "â˜ Push to remote (git push)"

  completing_phase:
    - "â˜ All phase features implemented"
    - "â˜ 100% test coverage with edge cases"
    - "â˜ Documentation complete"
    - "â˜ Roadmap updated (phase status: completed)"
    - "â˜ Git push"
    - "â˜ Discuss release strategy with user"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¤– AUTONOMOUS WORK REQUIREMENTS - IRONCLAD RULES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# These are NON-NEGOTIABLE requirements when working autonomously.
# Violation of ANY of these means the work is NOT production-ready.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

autonomous_work_requirements:
  philosophy: |
    When user says "work independently" or gives autonomous instructions,
    these requirements are MANDATORY. No shortcuts. No "almost done".
    Production-ready means ALL requirements met.

  testing_requirements:
    description: "100% test coverage is NON-NEGOTIABLE"

    unit_tests_required:
      - rule: "EVERY public function MUST have unit tests"
      - rule: "EVERY error path MUST be tested"
      - rule: "EVERY edge case MUST be covered"
      - examples:
          - "Empty inputs (empty strings, empty arrays, nulls)"
          - "Boundary values (0, negative, MAX_INT)"
          - "Invalid inputs (malformed data, wrong types)"
          - "Large inputs (1000+ rows, deeply nested structures)"

    e2e_tests_required:
      - rule: "EVERY user-facing command MUST have e2e tests"
      - rule: "E2E tests MUST use REAL test files (not mocks)"
      - rule: "E2E tests MUST cover happy path + failure modes"
      - examples:
          - "forge calculate: success case + stale values + errors"
          - "forge validate: passing + failing validation"
          - "forge export: YAML â†’ Excel with formulas"
          - "forge import: Excel â†’ YAML with formula translation"
          - "Round-trip: YAML â†’ Excel â†’ YAML (must be identical!)"

    test_data_required:
      - rule: "Create REAL test files in test-data/ directory"
      - rule: "Include edge case test files (empty, large, malformed)"
      - examples:
          - "test-data/export_basic.yaml (simple export test)"
          - "test-data/export_with_formulas.yaml (formula translation)"
          - "test-data/import_basic.xlsx (Excel import test)"
          - "test-data/import_with_formulas.xlsx (reverse translation)"
          - "test-data/roundtrip.yaml (start here, export, import, compare)"
          - "test-data/edge_cases/ (empty sheets, 1000+ rows, malformed)"

    coverage_verification:
      - command: "cargo test --release"
      - requirement: "ALL tests MUST pass (not 99%, ALL)"
      - command: "cargo test --release -- --nocapture"
      - requirement: "Run e2e tests and VERIFY actual files created/read"
      - verification: "Manually check test-data/ files exist and are correct"

  code_quality_requirements:
    description: "ZERO tolerance for warnings or errors"

    compilation:
      - command: "cargo build --release"
      - requirement: "MUST succeed with ZERO errors"
      - note: "If it doesn't compile, it's not done"

    linting:
      - command: "cargo clippy --release -- -D warnings"
      - requirement: "MUST pass with ZERO warnings"
      - note: "User has OCD for good looking code - use MOST STRICT linting"
      - action: "Fix ALL warnings before considering work complete"

    formatting:
      - command: "cargo fmt"
      - requirement: "MUST be run before every commit"
      - note: "Consistent formatting = professional code"

  documentation_requirements:
    description: "Documentation MUST be complete and accurate"

    inline_documentation:
      - rule: "EVERY public function MUST have doc comments"
      - rule: "Doc comments MUST include examples for non-trivial functions"
      - rule: "Error conditions MUST be documented"

    readme_updates:
      - rule: "README.md MUST reflect ALL new features"
      - rule: "CLI --help (src/main.rs) MUST match README messaging"
      - rule: "Usage examples MUST be tested and working"
      - rule: "Installation instructions MUST be current"
      - note: "Users see --help before README - keep them in sync!"

    roadmap_updates:
      - rule: "roadmap.yaml MUST be updated with phase completion"
      - rule: "current_version MUST match Cargo.toml"
      - rule: "Completed phases MUST be marked with timestamps"

    sred_documentation:
      - rule: "ğŸ docs/internal/SRED_RESEARCH_LOG.md MUST be updated for R&D work"
      - importance: "ğŸ’° CRITICAL - this = real money in tax credits"
      - requirement: "Document uncertainties, hypotheses, experiments, results"
      - frequency: "DURING development, not after"

  feature_completeness:
    description: "Features MUST be fully implemented, not partially"

    definition_of_done:
      - "âœ… Implementation complete (not 'mostly done')"
      - "âœ… Unit tests written and passing"
      - "âœ… E2E tests written and passing"
      - "âœ… Edge cases tested"
      - "âœ… Error handling tested"
      - "âœ… Documentation updated (inline, README, roadmap)"
      - "âœ… SR&ED documentation updated"
      - "âœ… ZERO warnings from clippy"
      - "âœ… Code formatted with cargo fmt"
      - "âœ… Git committed with descriptive message"

    not_done_if:
      - "âŒ Tests are commented out or skipped"
      - "âŒ TODO comments remain for core functionality"
      - "âŒ Error handling is missing or uses unwrap()"
      - "âŒ Documentation is placeholder or outdated"
      - "âŒ Clippy warnings exist ('I'll fix them later')"
      - "âŒ E2E tests don't exist for user-facing commands"
      - "âŒ Test data files don't exist"

  autonomous_work_checklist:
    description: "Use this checklist when working autonomously"

    before_starting:
      - "â˜ Read and understand user's autonomous instruction"
      - "â˜ Create TodoWrite list with ALL tasks (implementation + tests + docs)"
      - "â˜ Identify what tests need to be created (unit + e2e + test data)"
      - "â˜ Verify baseline: all existing tests passing"

    during_implementation:
      - "â˜ Write unit tests FIRST or alongside implementation"
      - "â˜ Create test data files as you go"
      - "â˜ Test edge cases (empty, null, invalid, large)"
      - "â˜ Document uncertainties in SR&ED log"
      - "â˜ Run tests frequently (cargo test)"
      - "â˜ Fix warnings immediately (don't accumulate)"

    after_implementation:
      - "â˜ Write e2e tests for ALL user-facing commands"
      - "â˜ Verify e2e tests with REAL files (not mocks)"
      - "â˜ Test round-trip scenarios (if applicable)"
      - "â˜ Run cargo clippy --release -- -D warnings â†’ ZERO warnings"
      - "â˜ Run cargo test --release â†’ ALL passing"
      - "â˜ Update inline documentation"
      - "â˜ Update README.md with new features"
      - "â˜ Update roadmap.yaml with completion status"
      - "â˜ Update SR&ED log with final results"
      - "â˜ Run cargo fmt"
      - "â˜ Git commit with descriptive message"

    before_reporting_complete:
      - "â˜ Double-check: ALL tests passing?"
      - "â˜ Double-check: ZERO clippy warnings?"
      - "â˜ Double-check: E2E tests exist and pass?"
      - "â˜ Double-check: Test data files exist?"
      - "â˜ Double-check: Documentation updated?"
      - "â˜ Double-check: SR&ED log updated?"
      - "â˜ If ANY checkbox unchecked â†’ NOT DONE, keep working"

  success_criteria:
    description: "How to know autonomous work is truly complete"

    technical_criteria:
      - "âœ… cargo build --release â†’ success"
      - "âœ… cargo test --release â†’ all tests pass"
      - "âœ… cargo clippy --release -- -D warnings â†’ zero warnings"
      - "âœ… cargo fmt â†’ already formatted"
      - "âœ… E2E tests exist for every user command"
      - "âœ… Test data files exist in test-data/"
      - "âœ… Round-trip tests pass (if applicable)"

    documentation_criteria:
      - "âœ… README.md reflects new features"
      - "âœ… roadmap.yaml shows completion"
      - "âœ… docs/internal/SRED_RESEARCH_LOG.md updated"
      - "âœ… Inline docs complete"

    quality_criteria:
      - "âœ… No unwrap() in library code"
      - "âœ… No TODOs for core functionality"
      - "âœ… Error messages are helpful"
      - "âœ… Edge cases handled gracefully"

    user_experience_criteria:
      - "âœ… Commands work as user expects"
      - "âœ… Error messages guide user to solution"
      - "âœ… Examples in README work when copy-pasted"
      - "âœ… Installation instructions are current"

  lessons_learned:
    v1_0_0_gap: |
      v1.0.0 was released with excellent unit tests for FormulaTranslator and
      ReverseFormulaTranslator, BUT missing e2e tests for `forge export` and
      `forge import` commands. This gap meant the core USER-FACING features
      were not tested end-to-end with real .xlsx files.

      LESSON: Unit tests alone are NOT enough. E2E tests for every user command
      are MANDATORY. Create test-data/*.xlsx files and verify round-trips.

      This is why these autonomous work requirements now exist.

release_workflow:
  description: "Automated release process"
  script: "./bin/release.sh <version> '<title>'"
  example: "./bin/release.sh 4.1.0 'Cross-file References'"
  details: "Script handles: build, UPX compress, install, tag, GH release, crates.io, doc reminders"
known_issues:
  note: "See GitHub issues for current bugs: https://github.com/royalbit/forge/issues"

current_implementation_focus:
  note: "Check roadmap.yaml for current version and status - this section is for reference only"
  capabilities:
    - "HTTP REST API Server (forge-server)"
    - "MCP Server for AI agents (forge-mcp)"
    - "LSP Server for editors (forge-lsp)"
    - "50+ Excel functions"
    - "Financial functions (NPV, IRR, PMT, FV, PV, RATE, NPER)"
  quality: "Run 'cargo test' for current test count - do NOT hardcode numbers here"

key_files_map:
  source:
    - "src/types.rs - Type definitions (ForgeVersion, ColumnValue, Table, ParsedModel)"
    - "src/parser/mod.rs - Parsing logic (parse_model for unified parsing)"
    - "src/core/array_calculator.rs - Array calculator for v1.0.0+ model"
    - "src/cli/commands.rs - CLI command implementations"
    - "src/api/server.rs - HTTP API server"
    - "src/mcp/server.rs - MCP server for AI agents"
    - "src/bin/forge_lsp.rs - LSP server for editors"

  tests:
    - "tests/parser_v1_tests.rs - v1.0 parser integration tests"
    - "tests/array_calculator_tests.rs - Array calculator tests"
    - "tests/e2e_tests.rs - End-to-end CLI tests"
    - "tests/validation_tests.rs - Validation workflow tests"

  documentation:
    - "README.md - User-facing documentation"
    - "docs/architecture/DESIGN_V1.md - v1.0.0 technical specification"
    - "roadmap.yaml - Development roadmap and progress"
    - "docs/GLOSSARY.md - Canonical terminology"
    - "schema/forge-v1.0.schema.json - JSON Schema for v1.0.0"

  examples:
    - "test-data/v1.0/saas_unit_economics.yaml"
    - "test-data/v1.0/quarterly_pl.yaml"
    - "test-data/v1.0/budget_vs_actual.yaml"

advanced_rust_patterns:
  description: "Rust patterns used in Forge - essential for autonomous development"

  error_handling:
    approach: "thiserror for rich error context"
    example: |
      #[derive(Error, Debug)]
      pub enum ForgeError {
          #[error("Formula evaluation failed: {0}")]
          Eval(String),
          #[error("Column '{column}' in table '{table}': {reason}")]
          ColumnError { column: String, table: String, reason: String },
      }
    best_practices:
      - "Use Result<T, E> everywhere, avoid panics in library code"
      - "Custom error types with thiserror for rich context"
      - "? operator for error propagation"
      - "Add context with .map_err() when wrapping errors"
    avoid:
      - "unwrap() or expect() in library code"
      - "String errors (not type-safe)"
      - "Losing error context when propagating"

  type_driven_design:
    principles:
      - "Make illegal states unrepresentable"
      - "Use newtypes for domain concepts (TableName, ColumnName)"
      - "Prefer enums over booleans for state"
      - "Use builder pattern for complex construction"
    newtype_example: |
      #[derive(Debug, Clone, PartialEq, Eq, Hash)]
      struct TableName(String);
      #[derive(Debug, Clone, PartialEq, Eq, Hash)]
      struct ColumnName(String);

  zero_copy:
    - "Use &str instead of String when possible"
    - "Use Cow<str> for conditional ownership"
    - "Pass large structs by reference"
    - "Avoid clone() unless necessary"

  testing_patterns:
    property_based:
      tool: "proptest"
      example: |
        proptest! {
            #[test]
            fn test_sum_commutative(a: f64, b: f64) {
                let sum1 = calculate("=SUM(a, b)");
                let sum2 = calculate("=SUM(b, a)");
                assert!((sum1 - sum2).abs() < 1e-10);
            }
        }
    snapshot: "insta - cargo insta review"
    mutation: "cargo-mutants - cargo mutants"
    fuzzing: "cargo-fuzz - cargo fuzz run parser_target"

  performance:
    benchmarking: "criterion - cargo bench"
    profiling: "perf/flamegraph on Linux, Instruments on Mac"
    rule: "Profile before optimizing, optimize hot paths only"

  architecture_patterns:
    strategy: |
      trait Calculator {
          fn calculate(&mut self) -> ForgeResult<CalculationResult>;
      }
      struct ArrayCalculator { /* v1.0.0 */ }
      impl Calculator for ArrayCalculator { /* ... */ }
    builder: |
      let table = TableBuilder::new("sales")
          .add_column(revenue_col)
          .add_formula("profit", "=revenue - expenses")
          .build()?;

  code_quality_tools:
    cargo_audit: "Security vulnerabilities"
    cargo_deny: "License/security policy"
    cargo_machete: "Unused dependencies"
    cargo_nextest: "Fast parallel tests"
    miri: "Undefined behavior detection"
    cargo_tarpaulin: "Code coverage"

  documentation_style:
    do:
      - "Use relatable metaphors and analogies"
      - "Add examples that tell a story"
      - "Celebrate what the code does well"
    dont:
      - "Humor in error messages (user is frustrated!)"
      - "Jargon without explanation"
      - "Just say 'invalid input' - be specific"

tips_for_success:
  critical:
    - "ğŸš¨ CHECK CURRENT DATE in <env> before ANY online search!"
    - "ZERO warnings policy - treat warnings as errors (user has OCD for clean code ğŸ˜Š)"
    - "Run cargo audit before releases (no surprises from dependency CVEs)"

  planning:
    - "Think harder before implementing - measure twice, code once ğŸ“"
    - "BEFORE complex code: Search crates.io (don't reinvent the wheel, it's already round)"
    - "Profile before optimizing - premature optimization is the root of all evil (and wasted time)"
    - "Read DESIGN_V1.md - comprehensive design docs exist for a reason!"

  testing:
    - "Write tests first when possible (TDD = sleep better at night)"
    - "Test edge cases - empty arrays, nulls, invalid inputs (Murphy's Law is undefeated)"
    - "Consider property-based testing for complex logic (test the rules, not examples)"
    - "If a bug makes it to production, write a test so it never comes back (revenge testing!)"

  type_safety:
    - "Use type system to prevent bugs (make illegal states unrepresentable)"
    - "Newtypes are your friends (TableName â‰  ColumnName, even though both are strings)"
    - "Enums over booleans (states > true/false)"
    - "Builder pattern for complex construction (fluent APIs are a joy to use)"

  code_quality:
    - "Run clippy frequently (it's like having a pedantic friend who's always right)"
    - "cargo fmt before every commit (consistency = readability)"
    - "No unwrap() in library code (Result<T,E> or bust)"
    - "Comments should explain WHY, not WHAT (code shows what, you explain why)"

  documentation:
    - "Update docs as you code, not after (future you will thank present you)"
    - "Add personality to docs - make them memorable (car keys, food trucks, cats ğŸ±)"
    - "Examples in rustdoc are tested (free test coverage!)"
    - "Error messages: helpful, not funny (user is frustrated, not entertained)"

  workflow:
    - "Commit frequently with descriptive messages (tell a story, not a changelog)"
    - "Use TodoWrite to track progress (Claude's memory needs help)"
    - "Check KNOWN_BUGS.md before fixing (might already be documented)"
    - "One feature per commit (atomic changes = easy reverts)"

  collaboration:
    - "Ask user for clarification on ambiguous requirements (assumptions are dangerous)"
    - "Check license compatibility (MIT-compatible only, GPL is the Voldemort of licenses)"
    - "When stuck, explain the problem out loud (rubber duck debugging works!)"

  wisdom:
    - "If it compiles in Rust, it probably works (type system FTW)"
    - "If tests pass but feel fragile, trust your instincts"
    - "Simpler code > clever code (cleverness is hard to debug at 2am)"
    - "When in doubt, add a test (tests never lie)"
    - "Break before optimize, fix before enhance, test before merge"

collaboration_notes:
  user_preferences:
    - "User values: zero errors, 100% accuracy, thorough testing"
    - "User has OCD for beautiful code - ZERO warnings, strict linting"
    - "User says 'Punch it!' when ready to proceed"
    - "User says 'Think harder' when wanting deeper analysis"
    - "User provides context from previous sessions via summary"
    - "Always check current date before online searches (training data is old!)"

session_end_checklist:
  description: "Verify pristine state before ending session"
  script: "./bin/session-end.sh"
  checks:
    - "cargo test --release (all passing)"
    - "cargo clippy (zero warnings)"
    - "cargo fmt --check (no changes needed)"
    - "git status (working directory clean)"
    - "git push (changes pushed to remote)"
grant_opportunities:
  description: "Canadian grant funding research guide"
  location: "docs/grants.md"
  when_to_read: "Before grant applications or quarterly research"
  company_status: "Woman-owned Canadian corporation, Montreal, Quebec"
  key_programs:
    - "NRC IRAP (Federal R&D)"
    - "SR&ED Tax Credits (Federal + Quebec)"
    - "Women entrepreneur programs"
    - "Quebec/Montreal innovation programs"
  note: "Programs change frequently - always verify current status via web search"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RECOMMENDATIONS FOR FUTURE IMPROVEMENTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

future_improvements:
  description: "Recommendations to evolve warmup.yaml and roadmap.yaml over time"

  warmup_protocol_improvements:
    quick_reference_section:
      priority: "HIGH"
      rationale: "Warmup is 2400+ lines - need TL;DR for returning sessions"
      implementation:
        - "Add 'quick_start' section at top with 20-line summary"
        - "List most critical rules: ZERO warnings, test coverage, time tracking"
        - "Link to detailed sections for deep dives"

    protocol_versioning:
      priority: "MEDIUM"
      rationale: "Track evolution of warmup protocol itself"
      implementation:
        - "Add version field (e.g., warmup_version: '2.0.0')"
        - "Add changelog section for significant protocol changes"
        - "Consider semantic versioning for protocol itself"

    automated_metrics_gathering:
      priority: "HIGH"
      rationale: "Eliminate manual metric collection"
      implementation:
        - "Create bin/gather-metrics.sh script"
        - "Auto-collect: test count, line count, coverage, warnings"
        - "Output in format ready for README/grants"
        - "Run as part of release checklist"

    separate_release_checklist:
      priority: "MEDIUM"
      rationale: "Release process is complex enough for dedicated file"
      implementation:
        - "Create release-checklist.yaml with step-by-step guide"
        - "Include pre-release, release, post-release phases"
        - "Add automation hooks for common tasks"

    test_coverage_automation:
      priority: "HIGH"
      rationale: "Track actual coverage percentages"
      implementation:
        - "Integrate cargo-tarpaulin for coverage reports"
        - "Add coverage thresholds to CI/CD"
        - "Generate coverage badges for README"

  roadmap_improvements:
    github_integration:
      priority: "HIGH"
      rationale: "Roadmap should reflect actual work"
      implementation:
        - "Create GitHub milestones matching roadmap versions"
        - "Use GitHub Projects for visual tracking"
        - "Link roadmap items to issues/PRs"

    user_feedback_loop:
      priority: "HIGH"
      rationale: "Roadmap should reflect user needs"
      implementation:
        - "Add GitHub Discussions for feature requests"
        - "Survey users on Excel feature priorities"
        - "Track feature requests in issues with labels"

    excel_compatibility_matrix:
      priority: "HIGH"
      rationale: "Critical goal needs detailed tracking"
      implementation:
        - "Create docs/EXCEL_COMPATIBILITY.md"
        - "List all Excel functions with status (supported/planned/not-planned)"
        - "Track Excel features (pivot tables, charts, etc.) with roadmap links"
        - "Add test cases for each Excel function"

    dependency_upgrade_schedule:
      priority: "MEDIUM"
      rationale: "Proactive security and features"
      implementation:
        - "Schedule monthly dependency reviews"
        - "Track breaking changes in major deps"
        - "Test thoroughly after upgrades"

  ci_cd_improvements:
    github_actions:
      priority: "HIGH"
      rationale: "Automate quality gates"
      implementation:
        - "Create .github/workflows/ci.yml"
        - "Run all linting (clippy, fmt, markdownlint, yamllint)"
        - "Run all tests (unit, integration, e2e)"
        - "Fail on ANY warning"
        - "Auto-generate release notes"

    automated_releases:
      priority: "MEDIUM"
      rationale: "Reduce manual release steps"
      implementation:
        - "Auto-publish to crates.io on tag"
        - "Auto-create GitHub release"
        - "Auto-build binaries for multiple platforms"

  documentation_improvements:
    openapi_automation:
      priority: "HIGH"
      rationale: "API docs should auto-generate"
      implementation:
        - "Create openapi.yaml for API server"
        - "Auto-generate from code annotations (utoipa crate)"
        - "Host Swagger UI at /api/docs"
        - "Generate client SDKs (Python, JS, etc.)"

    architecture_diagrams:
      priority: "MEDIUM"
      rationale: "Visual docs aid understanding"
      implementation:
        - "Keep Mermaid diagrams in markdown (GitHub renders them)"
        - "Auto-generate dependency graphs"
        - "Add sequence diagrams for complex flows"

    changelog_automation:
      priority: "MEDIUM"
      rationale: "Changelog should auto-generate from commits"
      implementation:
        - "Use conventional commits format"
        - "Auto-generate CHANGELOG.md from git history"
        - "Include in release process"

  community_growth:
    contribution_guidelines:
      priority: "LOW (for now)"
      rationale: "Prepare for community contributions"
      implementation:
        - "Create CONTRIBUTING.md"
        - "Define coding standards (reference warmup)"
        - "Set up issue templates"
        - "Define PR review process"

    documentation_i18n:
      priority: "LOW"
      rationale: "Reach non-English users"
      implementation:
        - "French documentation (Quebec market)"
        - "Other languages based on user base"

  immediate_actions:
    next_session:
      - "Create docs/EXCEL_COMPATIBILITY.md matrix"
      - "Create openapi.yaml for API server"
      - "Update JSON Schema to v2.0.0"
      - "Set up basic GitHub Actions CI"

    next_release:
      - "Add automated metrics gathering script"
      - "Create quick_start section in warmup.yaml"
      - "Add coverage tracking with cargo-tarpaulin"

  meta:
    last_reviewed: "Update this date when reviewing recommendations"
    review_frequency: "Review quarterly or after major releases"
