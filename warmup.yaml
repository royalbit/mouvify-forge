# üî• Forge - Session Warmup Checklist
# Purpose: Initialize Claude Code sessions with full context and workflow
# Usage: User says "run warmup" or "run warmup.yaml"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# THE FORGE PROTOCOL SUITE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# Two complementary protocols for sustainable autonomous AI development:
#
# ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
# ‚îÇ                         FORGE PROTOCOL SUITE                                 ‚îÇ
# ‚îÇ                                                                              ‚îÇ
# ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
# ‚îÇ   ‚îÇ    WARMUP PROTOCOL      ‚îÇ       ‚îÇ  SPRINT AUTONOMY        ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ    (this file)          ‚îÇ   +   ‚îÇ  PROTOCOL               ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ                         ‚îÇ       ‚îÇ  (docs/SPRINT_...md)    ‚îÇ            ‚îÇ
# ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§            ‚îÇ
# ‚îÇ   ‚îÇ HOW to develop:         ‚îÇ       ‚îÇ WHEN to stop:           ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ ‚Ä¢ Quality standards     ‚îÇ       ‚îÇ ‚Ä¢ Bounded sessions      ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ ‚Ä¢ Coding principles     ‚îÇ       ‚îÇ ‚Ä¢ Milestone sizing      ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ ‚Ä¢ Testing requirements  ‚îÇ       ‚îÇ ‚Ä¢ Shipping discipline   ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ ‚Ä¢ Documentation rules   ‚îÇ       ‚îÇ ‚Ä¢ Anti-pattern guards   ‚îÇ            ‚îÇ
# ‚îÇ   ‚îÇ ‚Ä¢ What "done" means     ‚îÇ       ‚îÇ ‚Ä¢ Quota preservation    ‚îÇ            ‚îÇ
# ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
# ‚îÇ                                                                              ‚îÇ
# ‚îÇ   Together: Production-ready code that actually ships                       ‚îÇ
# ‚îÇ   See: docs/SPRINT_AUTONOMY_PROTOCOL.md for the full Sprint Protocol        ‚îÇ
# ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CRITICAL MISSION - Why Forge Exists
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

mission:
  core_problem: |
    AI hallucinations in financial modeling cost enterprises $40K-$132K/year.
    Excel is the standard, but it lacks version control, testability, and AI-friendliness.
    Users need YAML files that work like Excel but integrate with modern workflows.

  solution: |
    Forge: A bidirectional Excel-YAML bridge with formula evaluation.
    - YAML files replace Excel for financial models
    - Maximum Excel compatibility (formulas, functions, features)
    - AI can read/write YAML without hallucinating numbers
    - Version control, code review, CI/CD for spreadsheets

  critical_priority: "EXCEL COMPATIBILITY IS PARAMOUNT"
  priority_order:
    1: "Excel formula compatibility (all Excel functions should work)"
    2: "Excel feature parity (pivot tables, multiple sheets/documents, charts)"
    3: "Bidirectional conversion (YAML ‚Üî Excel with zero data loss)"
    4: "AI integration (MCP, LSP, API for AI agents)"
    5: "Developer experience (CLI, validation, watch mode)"

  success_metric: "A user can replace their Excel workflow with Forge YAML files"

  roadmap_ownership: |
    Claude (AI) owns the roadmap and updates it based on:
    - User feedback and requests
    - Market research on Excel features users need
    - Technical feasibility and dependencies
    - Best judgment on priorities
    The roadmap should be updated proactively and reflected in README.

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# AUTONOMOUS DEVELOPMENT PROTOCOL - "Skynet Mode" ü§ñ
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

autonomous_development:
  description: |
    AI Autonomy Protocol for bounded, productive development sessions.
    Claude owns the code, documentation, and decisions - but within constraints
    that ensure work actually ships instead of running forever.

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # SESSION TRIGGER FLOW - How autonomous sessions start
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  #
  # This section MUST survive /compact operations in Claude Code CLI.
  # It defines the contract between user and AI for autonomous work.

  session_trigger_flow:
    step_1_trigger:
      user_says:
        - "run warmup"
        - "run warmup protocol"
        - "warmup"
        - "start session"
      claude_does:
        - "Read warmup.yaml (this file)"
        - "Read roadmap.yaml for next milestone"
        - "Check git status and current state"
        - "Load essential context (README, Cargo.toml)"

    step_2_present:
      claude_presents: |
        üìã NEXT MILESTONE: [milestone name from roadmap]
        ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        Scope: [brief description]
        Estimated: [X hours]
        Deliverables:
          - [deliverable 1]
          - [deliverable 2]
          - [etc.]

        Release targets:
          ‚òê GitHub (commit + tag + push)
          ‚òê Local install (make install-user)
          ‚òê crates.io (cargo publish)

        Say "go", "run", "hit it", or "punch it" to start autonomous execution.
        Say "skip" to pick a different milestone.
        Say "plan" to discuss the approach first.

    step_3_confirm:
      user_confirms_with:
        - "go"
        - "run"
        - "hit it"
        - "punch it"
        - "do it"
        - "execute"
        - "ship it"
        - "let's go"
        - "start"
        - "begin"
        - "approved"
        - "yes"
        - "y"
      alternative_responses:
        skip: "User wants different milestone - present alternatives"
        plan: "User wants to discuss approach - enter planning mode"
        questions: "User has questions - answer then re-present"

    step_4_autonomous_execution:
      claude_behavior: |
        ü§ñ AUTONOMOUS MODE ACTIVATED

        From this point until release, Claude works WITHOUT interruption:
        - Makes all technical decisions independently
        - Writes code, tests, documentation
        - Fixes any issues that arise
        - Does NOT ask questions (uses best judgment)
        - Does NOT wait for approval
        - Updates TodoWrite to show progress

        ONLY interrupts user if:
        - Blocked by external dependency (missing API key, etc.)
        - Fundamental requirement ambiguity that can't be resolved
        - Session approaching 4-hour limit without completion

      execution_checklist:
        - "‚òê Create TodoWrite with milestone tasks"
        - "‚òê Implement feature/fix"
        - "‚òê Write/update tests"
        - "‚òê Run all tests (must pass)"
        - "‚òê Run all linting (ZERO warnings)"
        - "‚òê Update documentation"
        - "‚òê Update CHANGELOG.md"
        - "‚òê Bump version in Cargo.toml"

    step_5_release:
      description: "Full release to all targets"
      release_sequence:
        github:
          - "git add -A"
          - "git commit -m 'chore: Release vX.Y.Z - [milestone]'"
          - "git tag vX.Y.Z"
          - "git push origin main"
          - "git push origin vX.Y.Z"
        local_install:
          - "make install-user (or cargo install --path .)"
          - "Verify: forge --version"
        crates_io:
          - "cargo publish"
          - "Verify: https://crates.io/crates/royalbit-forge"

    step_6_report:
      claude_reports: |
        ‚úÖ RELEASE COMPLETE: vX.Y.Z
        ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        Milestone: [milestone name]
        Duration: [X hours Y minutes]

        Deliverables:
          ‚úÖ [deliverable 1]
          ‚úÖ [deliverable 2]

        Release targets:
          ‚úÖ GitHub: [commit hash] tagged vX.Y.Z
          ‚úÖ Local: forge vX.Y.Z installed
          ‚úÖ crates.io: https://crates.io/crates/royalbit-forge/X.Y.Z

        Tests: [N] passing, ZERO warnings

        Session logged in AI_DEVELOPMENT_HOURS.md

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # COMPACT SURVIVAL - Essential context for /compact operations
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  compact_survival:
    description: |
      When Claude Code CLI runs /compact, context is compressed.
      This section contains ESSENTIAL information that MUST be retained.

    essential_rules:
      - "ZERO warnings policy - ALL linting must pass"
      - "Tests MUST pass before any release"
      - "Release to ALL targets: GitHub + local + crates.io"
      - "4-hour maximum session duration"
      - "ONE milestone per session"
      - "Update CHANGELOG.md for every release"
      - "Bump version in Cargo.toml"
      - "Tag releases with vX.Y.Z format"

    essential_files:
      - "warmup.yaml - This protocol file"
      - "roadmap.yaml - Milestone definitions"
      - "Cargo.toml - Version and dependencies"
      - "README.md - User-facing documentation"
      - "CHANGELOG.md - Release history"

    release_commands:
      github: "git add -A && git commit && git tag vX.Y.Z && git push && git push --tags"
      local: "make install-user"
      crates: "cargo publish"

  philosophy: |
    üéØ GOAL: AI develops Forge autonomously with ZERO human intervention
    ‚è±Ô∏è CONSTRAINT: Sessions must be bounded (quota preservation, shipping cadence)
    üì¶ OUTPUT: Every session ends in a RELEASABLE state
    üöÄ MANTRA: "Done is better than perfect. Ship it."

  why_bounded_sessions:
    quota_reality: "Unbounded sessions kill Claude subscription quotas"
    shipping_cadence: "Work that never ships has zero value"
    focus_discipline: "Constraints force prioritization and prevent scope creep"
    incremental_progress: "Small releases > big bang releases that never happen"

  session_types:
    sprint_session:
      description: "Standard autonomous development session"
      duration: "2-4 hours maximum"
      scope: "ONE milestone, ONE releasable outcome"
      end_state: "Tests pass, docs updated, ready to publish"

    micro_session:
      description: "Quick fix or small enhancement"
      duration: "30 minutes - 1 hour"
      scope: "Single bug fix, doc update, or minor feature"
      end_state: "Commit ready, optional release"

    research_session:
      description: "Exploration without code changes"
      duration: "1-2 hours"
      scope: "Investigation, planning, documentation"
      end_state: "Findings documented, no code changes required"

  milestone_sizing:
    golden_rule: "Can this be completed AND shipped in 4 hours or less?"

    too_small:
      examples:
        - "Fix typo in README"
        - "Rename one variable"
        - "Add one test"
      problem: "Context loading overhead exceeds value"
      solution: "Batch multiple small items into one session"

    just_right:
      examples:
        - "Add Excel pivot table support"
        - "Implement new CLI command"
        - "Add JSON Schema validation for new feature"
        - "Create OpenAPI spec for API server"
        - "Fix 5 related bugs in one module"
      characteristics:
        - "Single coherent feature or improvement"
        - "End-to-end (code + tests + docs)"
        - "Achievable in one focused session"
        - "Meaningful value to users"

    too_big:
      examples:
        - "Implement v3.0 with all planned features"
        - "Rewrite entire codebase in new architecture"
        - "Add support for 50 new Excel functions"
      problem: "Will never complete, scope creeps, frustration"
      solution: "Break into multiple just-right milestones"

  session_flow:
    phase_1_define:
      duration: "5-10 minutes"
      actions:
        - "State ONE milestone clearly"
        - "Define success criteria (what does 'done' look like?)"
        - "Set time budget (default: 4 hours max)"
        - "Identify known risks or blockers"
      output: "Clear milestone statement in TodoWrite"

    phase_2_execute:
      duration: "Bulk of session (2-4 hours)"
      actions:
        - "Full autonomy - make decisions, write code, fix issues"
        - "Stay focused on milestone - resist tangents"
        - "Update TodoWrite as you progress"
        - "Document decisions and tradeoffs"
      rules:
        - "üö´ NO 'Let me also...' - that's next milestone"
        - "üö´ NO 'While I'm here...' - stay focused"
        - "üö´ NO 'This would be better if...' - ship first, improve later"
        - "üö´ NO perfectionism - ENEMY of shipping"

    phase_3_ship:
      duration: "15-30 minutes"
      actions:
        - "Run ALL tests (must pass)"
        - "Run ALL linting (ZERO warnings)"
        - "Update documentation"
        - "Update CHANGELOG if releasing"
        - "Commit with clear message"
        - "Tag version if releasing"
        - "Publish to crates.io if releasing"
      gate: "DO NOT proceed unless session_end_checklist passes"

    phase_4_stop:
      duration: "Immediate"
      rule: "MANDATORY stop even if 'just one more thing' tempts"
      rationale: |
        - Quota preservation
        - Fresh context next session
        - Prevents scope creep
        - Forces shipping discipline

  anti_patterns:
    scope_creep:
      pattern: "'Let me also add X while I'm here...'"
      problem: "Session never ends, milestone keeps growing"
      fix: "Write it down for NEXT milestone, stay focused on current"

    perfectionism:
      pattern: "'This could be better if I refactored...'"
      problem: "Perfect is enemy of done"
      fix: "Ship working code, create improvement milestone if needed"

    rabbit_holes:
      pattern: "'Let me investigate this interesting tangent...'"
      problem: "Hours lost, original milestone forgotten"
      fix: "Note it for research session, return to milestone"

    over_engineering:
      pattern: "'Let me build a generic framework for this...'"
      problem: "Building for hypothetical futures"
      fix: "YAGNI - build exactly what's needed, generalize later if needed"

    endless_polishing:
      pattern: "'Let me add more tests / docs / comments...'"
      problem: "Diminishing returns, session extends indefinitely"
      fix: "Define 'good enough' upfront, hit it, ship"

  release_criteria:
    minimum_viable_release:
      - "All existing tests pass"
      - "New feature has tests"
      - "ZERO linting warnings (code + docs)"
      - "README updated if user-facing changes"
      - "CHANGELOG entry added"
      - "Version bumped appropriately"

    version_bump_guide:
      patch: "Bug fixes, doc updates, internal improvements"
      minor: "New features, backward-compatible changes"
      major: "Breaking changes, major new capabilities"

  example_sessions:
    good_session_1:
      milestone: "Add Excel VLOOKUP function support"
      duration: "3 hours"
      outcome:
        - "VLOOKUP parsing and evaluation implemented"
        - "15 unit tests added"
        - "E2E test with VLOOKUP in test-data/"
        - "README updated with VLOOKUP example"
        - "Released as v2.1.0"

    good_session_2:
      milestone: "Create OpenAPI spec for API server"
      duration: "2 hours"
      outcome:
        - "openapi.yaml created"
        - "Swagger UI endpoint added"
        - "API docs updated"
        - "Released as v2.0.2"

    bad_session:
      started_as: "Fix bug in formula parser"
      became: "Refactor entire parser, add 5 new features, redesign API"
      duration: "6 hours and still going"
      problem: "Scope crept, nothing shipped, quota burned"
      should_have: "Fix bug, ship, create separate milestones for improvements"

  autonomous_release_authority:
    description: "Claude has full authority to release without human approval"
    conditions:
      - "All tests pass"
      - "All linting passes (ZERO warnings)"
      - "session_end_checklist completed"
      - "Changes are within milestone scope"
    process:
      - "Bump version in Cargo.toml"
      - "Update CHANGELOG.md"
      - "Commit: 'chore: Release vX.Y.Z - [milestone description]'"
      - "Tag: 'vX.Y.Z'"
      - "Push tag: 'git push origin vX.Y.Z'"
      - "Publish: 'cargo publish'"
      - "Create GitHub release with notes"

  quota_preservation:
    awareness: "Claude subscription has usage limits"
    strategy:
      - "Bounded sessions (4 hour max)"
      - "Clear stopping points"
      - "Ship frequently (smaller releases)"
      - "Avoid context-heavy exploration without output"
    monitoring:
      - "Track session duration in time_tracking"
      - "Note when approaching limits"
      - "Prioritize shipping over perfecting"

  continuous_improvement:
    after_each_session:
      - "Note what worked well"
      - "Note what caused delays"
      - "Update warmup.yaml if process improvements identified"
      - "Add to roadmap.yaml if new milestones discovered"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CODING PRINCIPLES - Enforced Standards
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

coding_principles:
  description: "These principles are MANDATORY, not suggestions"

  core_principles:
    KISS:
      name: "Keep It Simple, Stupid"
      rule: "The simplest solution that works is the best solution"
      violation: "Over-engineering, premature abstraction, unnecessary complexity"

    DRY:
      name: "Don't Repeat Yourself"
      rule: "Every piece of knowledge must have a single, authoritative representation"
      violation: "Copy-pasted code, duplicated logic, repeated constants"

    YAGNI:
      name: "You Aren't Gonna Need It"
      rule: "Don't implement features until they're actually needed"
      violation: "Building for hypothetical future requirements"

    SOLID:
      S: "Single Responsibility - Each module/function does ONE thing"
      O: "Open/Closed - Open for extension, closed for modification"
      L: "Liskov Substitution - Subtypes must be substitutable for base types"
      I: "Interface Segregation - Many specific interfaces > one general interface"
      D: "Dependency Inversion - Depend on abstractions, not concretions"

    separation_of_concerns:
      rule: "Each module handles one aspect of functionality"
      example: "Parser parses, Calculator calculates, Writer writes"

    law_of_demeter:
      rule: "Only talk to your immediate friends"
      violation: "object.getA().getB().getC().doThing()"
      fix: "object.doThing() - let object handle the chain internally"

    composition_over_inheritance:
      rule: "Prefer composing objects over inheriting from classes"
      why: "More flexible, easier to test, avoids inheritance hell"

    fail_fast:
      rule: "Detect and report errors as early as possible"
      example: "Validate inputs at function entry, not deep in processing"

    convention_over_configuration:
      rule: "Sensible defaults that work without configuration"
      example: "forge calculate file.yaml just works, no config needed"

    boy_scout_rule:
      rule: "Leave the code cleaner than you found it"
      action: "Small improvements while working on a file"

    encapsulation:
      rule: "Hide internal details, expose clean interfaces"
      violation: "pub struct with pub fields that expose implementation"

    principle_of_least_astonishment:
      rule: "Code should behave as users expect"
      example: "SUM() should sum, not average. Names should match behavior."

  enforcement: |
    Before committing ANY code, verify:
    - Is this the simplest solution? (KISS)
    - Am I repeating myself? (DRY)
    - Is this actually needed now? (YAGNI)
    - Does each function do ONE thing? (SRP)
    - Would this surprise a reader? (Least Astonishment)

session_initialization:
  greeting: "Welcome back! Loading Forge context..."

  time_tracking:
    description: "Track AI development hours - backs up 'Built by AI in X hours' claims"
    importance: "üí∞ Required for README claims, SR&ED docs, grant applications"

    on_session_start:
      action: "Record session start time"
      command: "date '+%Y-%m-%d %H:%M:%S'"
      store_as: "SESSION_START_TIME"
      announce: "Session started at [TIME]"

    on_session_end:
      action: "Calculate and log session duration"
      steps:
        - "Calculate duration from SESSION_START_TIME"
        - "Add to cumulative hours in docs/internal/AI_DEVELOPMENT_HOURS.md"
        - "Announce: 'Session duration: X hours (Total: Y hours)'"

    verification:
      git_log_check:
        command: "git log --format='%ai' --reverse | head -1"
        purpose: "Get first commit timestamp (project start)"
      git_hours_estimate:
        command: "git log --format='%ai %s' --author='Claude'"
        purpose: "Review AI commit timeline"
      cross_reference:
        - "Logged session hours MUST align with git commit timeline"
        - "If discrepancy > 10%, investigate and reconcile"

    hours_log_file:
      path: "docs/internal/AI_DEVELOPMENT_HOURS.md"
      format: |
        # AI Development Hours Log

        ## Summary
        - **Total Hours:** X hours
        - **First Session:** YYYY-MM-DD
        - **Latest Session:** YYYY-MM-DD

        ## Session Log
        | Date | Start | End | Duration | Work Done |
        |------|-------|-----|----------|-----------|
        | YYYY-MM-DD | HH:MM | HH:MM | X.Xh | Description of work done |
        | ... | ... | ... | ... | ... |

  step_1_load_context:
    description: "Read these files to understand current state"
    files_to_read:
      - path: "README.md"
        purpose: "Project overview, features, usage examples"

      - path: "roadmap.yaml"
        purpose: "Current version, implementation phases, progress tracking"
        key_sections:
          - "metadata.current_version"
          - "milestones"
          - "features"

      - path: "docs/architecture/DESIGN_V1.md"
        purpose: "v1.0.0 array model specification (comprehensive technical design)"
        key_sections:
          - "Model Structure"
          - "Formula Evaluation"
          - "Type System"
          - "Testing Strategy"

      - path: "docs/GLOSSARY.md"
        purpose: "Canonical terminology for consistency across docs and code"
        action: "Reference when writing documentation or naming things"

      - path: "docs/internal/SRED_RESEARCH_LOG.md"
        purpose: "üçÅ SR&ED R&D documentation for Canadian tax credits"
        action: "Review existing entries, add new ones for qualifying R&D work"
        importance: "üí∞ CRITICAL - this documentation = real money in tax credits"

      - path: "Cargo.toml"
        purpose: "Current version number, dependencies"
        key_fields:
          - "version"
          - "dependencies"

      - path: "schema/forge-v1.0.schema.json"
        purpose: "JSON Schema for v1.0.0 model validation"
        note: "Update when adding new features to v1.0.0 model"

  step_1b_check_current_date:
    description: "CRITICAL: Always check current date for online searches"
    importance: "üö® HIGH PRIORITY üö®"
    rationale: "Claude's training data is several months old (Jan 2025 cutoff)"

    what_to_do:
      - "ALWAYS check <env> tag for Today's date before online searches"
      - "When searching: Add current year/date to query"
      - "Example: 'Rust async 2025' NOT 'Rust async'"
      - "Verify crates.io versions are CURRENT, not from training data"
      - "Check GitHub repos for recent activity before recommending"

    bad_example:
      query: "best rust excel library"
      problem: "Might return 2024 results if Claude assumes old date"

    good_example:
      query: "best rust excel library <CURRENT_YEAR>"
      check_env: "Run 'date' to get current date - include year in searches"
      note: "Explicitly include current year in search to avoid stale results"

  step_2_git_status:
    description: "Check current branch and uncommitted changes"
    commands:
      - "git status"
      - "git log --oneline -5"
      - "git branch --show-current"
    expected_branch: "main (or feature branch if working on specific feature)"
    action: "If on different branch, ask user about intent"

  step_2b_validation_baseline:
    description: "Run validation and ensure ZERO errors before starting work"
    importance: "üö® CRITICAL - Documentation is code. ZERO tolerance for linting errors."
    rationale: |
      Documentation is code. Linting errors are like compiler warnings.
      User has OCD for good looking code - applies to ALL code, including docs.
      ZERO linting errors = clean codebase = peace of mind.

    commands:
      markdown_lint:
        command: "make validate-docs"
        tool: "markdownlint-cli2"
        config: ".markdownlint.json"
        install: "npm install -g markdownlint-cli2"
        validates:
          - "README.md"
          - "docs/**/*.md"
        requirement: "ZERO errors"

      yaml_lint:
        command: "make validate-yaml"
        tool: "yamllint"
        config: ".yamllint"
        install: "pip install yamllint"
        validates:
          - "warmup.yaml"
          - "roadmap.yaml"
        requirement: "ZERO errors"

      full_validation:
        command: "make validate-all"
        runs: "All validators in sequence"
        requirement: "ALL must pass with ZERO errors"

    if_validation_fails:
      - "üö® STOP - Fix linting errors before continuing"
      - "Linting errors are bugs in documentation"
      - "Do NOT proceed with other work until validation passes"
      - "Same standard as cargo clippy: ZERO tolerance"

    reporting:
      template: |
        Validation Status:
        - Markdown: PASS (0 errors) ‚úÖ
        - YAML: PASS (0 errors) ‚úÖ

  step_3_assume_pristine:
    description: "Assume codebase is pristine - we enforce this at session END"
    philosophy: |
      Sessions ALWAYS end with pristine code (all tests passing, all linting clean).
      Therefore, we ASSUME pristine state at session START - no need to re-verify.
      This saves time and avoids redundant checks.

    what_we_skip:
      - "cargo test (already passed at end of last session)"
      - "cargo clippy (already clean at end of last session)"
      - "make validate-all (already clean at end of last session)"

    quick_sanity_check:
      command: "cargo build --release"
      purpose: "Quick compile check (catches obvious issues like missing files)"
      expected: "Compiles successfully"
      note: "If this fails, something external changed - investigate"

    why_this_works: |
      The session_end_checklist enforces:
      - All tests passing
      - All linting clean (code + docs)
      - All changes committed and pushed
      If we always END clean, we always START clean.

  test_requirements:
    description: "Test standards enforced at session END, not warmup"
    philosophy: |
      This is a critical financial tool. Test coverage requirements:
      - 100% unit test coverage (every public function)
      - E2E tests for ALL user-facing features (CLI + API + MCP + LSP)
      - ZERO failures, ZERO ignored tests
      - Tests are documentation - they define expected behavior

    coverage_requirements:
      unit_tests:
        principle: "100% coverage of public API"
        rules:
          - "Every public function MUST have unit tests"
          - "Every error path MUST be tested"
          - "Every edge case MUST be covered"
          - "Tests evolve WITH the code - add/remove as features change"

      e2e_tests:
        principle: "Every user-facing feature MUST have E2E tests"
        rules:
          - "Every CLI command MUST have E2E tests (success + failure cases)"
          - "Every API endpoint MUST have E2E tests"
          - "Every MCP tool MUST have E2E tests"
          - "Every LSP feature MUST have E2E tests"
          - "Tests evolve WITH the code - add/remove as features change"
        note: "Do NOT hardcode feature lists here - they become stale"

    quality_bar: "If a feature exists, it MUST have tests. No exceptions."

  step_4_understand_workflow:
    description: "Our development workflow and standards"
    standards:
      testing:
        unit_tests:
          - "100% coverage of new code"
          - "Test happy paths AND edge cases"
          - "Test error conditions"
          - "Use descriptive test names"

        integration_tests:
          - "Test with real v1.0 example files"
          - "Test cross-module interactions"

        e2e_tests:
          - "Test full CLI workflows"
          - "Test with multiple file scenarios"
          - "Test error handling"

        edge_cases:
          - "Empty arrays"
          - "Single-element arrays"
          - "Very large numbers"
          - "Division by zero"
          - "Circular dependencies"
          - "Missing columns"
          - "Type mismatches"
          - "Malformed YAML"

      code_quality:
        - "No warnings in release build (ZERO tolerance)"
        - "Use meaningful variable names"
        - "Add doc comments for public APIs"
        - "Follow existing code style"
        - "Prefer Edit over Write for existing files"

      linting:
        philosophy: "User has OCD for good looking code üòä - use MOST STRICT linting"
        requirements:
          - "Run cargo clippy --all-targets -- -D warnings (treat warnings as errors)"
          - "Use rustfmt with default settings"
          - "No unused imports, variables, or functions"
          - "Prefer explicit over implicit (no _ when you can name it)"
          - "Use clippy pedantic when possible"
        commands:
          - "cargo fmt -- --check (verify formatting)"
          - "cargo clippy --release -- -D warnings (no warnings allowed)"
          - "cargo build --release (must be clean)"

      git_workflow:
        commit_messages:
          format: |
            <Title: imperative mood, 50 chars>

            <Body: what and why, 72 char wrap>

            Key additions:
            - Feature 1
            - Feature 2

            Test coverage: X tests passing

            ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

            Co-Authored-By: Claude <noreply@anthropic.com>

          examples:
            - "Add support for aggregation formulas"
            - "Fix precision issues in array calculator"
            - "Update roadmap with Phase 2 progress"

        commit_strategy:
          - "Commit logical units of work"
          - "Keep commits focused and atomic"
          - "Run tests before committing"
          - "Update roadmap in separate commit"

      sred_documentation:
        description: "üçÅ SR&ED Tax Credits - Document R&D work for Canadian tax credits"
        importance: "üö® CRITICAL - Document BEFORE committing"
        file: "docs/internal/SRED_RESEARCH_LOG.md"

        what_is_sred:
          program: "Scientific Research & Experimental Development (Canada)"
          benefit: "Tax credits for R&D work (refundable in some cases)"
          eligibility: "Technical challenges, systematic investigation, technological advancement"

        when_to_document:
          - "üö® BEFORE committing new algorithms or data structures"
          - "üö® BEFORE committing experimental approaches or optimizations"
          - "üö® BEFORE committing solutions to technical uncertainties"
          - "After resolving performance issues"
          - "After experimenting with alternative approaches"
          - "When creating novel abstractions or patterns"

        what_to_document:
          technical_challenge:
            - "What problem are we solving?"
            - "Why is it technically uncertain?"
            - "What makes it non-trivial/non-obvious?"
          hypothesis:
            - "What approach did we try?"
            - "What alternatives did we consider?"
            - "Why did we choose this approach?"
          experiment:
            - "What did we implement?"
            - "What tests did we run?"
            - "What measurements did we take?"
          results:
            - "Did it work? Why or why not?"
            - "What did we learn?"
            - "Were there unexpected findings?"
          advancement:
            - "What new capability did we create?"
            - "How does it advance the state of the art?"
            - "What can users now do that they couldn't before?"

        qualifying_activities:
          yes:
            - "‚úÖ Algorithm design and optimization"
            - "‚úÖ Performance analysis and improvements"
            - "‚úÖ Experimental testing approaches (property-based, mutation, fuzzing)"
            - "‚úÖ Resolving technical uncertainties"
            - "‚úÖ Creating novel data structures and abstractions"
            - "‚úÖ Dependency resolution algorithms"
            - "‚úÖ Type system design"
          no:
            - "‚ùå Routine coding (following established patterns)"
            - "‚ùå UI design and styling"
            - "‚ùå Documentation writing (unless documenting research)"
            - "‚ùå Bug fixes for simple typos"
            - "‚ùå Standard library integration"

        workflow:
          - "1Ô∏è‚É£ Identify if work qualifies for SR&ED (see qualifying_activities)"
          - "2Ô∏è‚É£ If YES: Document in docs/internal/SRED_RESEARCH_LOG.md DURING development"
          - "3Ô∏è‚É£ Include: Challenge, Hypothesis, Experiment, Results, Advancement"
          - "4Ô∏è‚É£ Be specific about technical challenges and alternatives considered"
          - "5Ô∏è‚É£ Link to commits, test results, benchmarks"
          - "6Ô∏è‚É£ THEN commit code"

        example_entry_title:
          - "Entry X: Aggregation Formula Evaluation (Phase 2 Part 2)"
          - "Entry X: Zero-Copy String Optimization"
          - "Entry X: Property-Based Testing for Formula Invariants"

        reminder: "üí∞ This documentation = real money in tax credits. Don't skip it!"

      diagrams:
        description: "üìä Mermaid architecture and design diagrams"
        importance: "Visual documentation for complex systems"
        format: "Embedded Mermaid in markdown files"
        rendering: "GitHub renders Mermaid natively"

        üö®_CRITICAL_RULE: |
          NO ASCII ART DIAGRAMS in documentation!

          ‚ùå FORBIDDEN:
            ```
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ  Box A  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  Box B  ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ```

          ‚úÖ REQUIRED (Mermaid):
            ```mermaid
            graph LR
              A[Box A] --> B[Box B]
            ```

          WHY:
          - ASCII breaks on different fonts/editors
          - ASCII doesn't scale or reflow
          - ASCII can't be automatically themed (light/dark)
          - Mermaid is GitHub-native, interactive, maintainable

          EXCEPTION: YAML comments (like this warmup.yaml header) can use ASCII
          since they're not rendered markdown.

        when_to_create:
          major_versions:
            - "New major release (v1.0, v2.0) - architecture overview"
            - "Significant architectural changes - component diagrams"
            - "New subsystems - integration diagrams"
          complex_features:
            - "Multi-step workflows - sequence diagrams"
            - "Decision logic - flowcharts"
            - "Data model changes - class diagrams"
          documentation:
            - "README needs visual aid - architecture diagram"
            - "DESIGN_V1 explaining algorithms - flow diagram"
            - "SRED explaining novel approach - sequence/component diagram"

        diagram_types:
          flowchart:
            when: "System architecture, data flow, decision logic"
            example: "graph TB for top-bottom, graph LR for left-right"
          sequence:
            when: "User workflows, cross-component interactions"
            example: "sequenceDiagram for time-based flows"
          class:
            when: "Data models, type systems"
            example: "classDiagram for type hierarchies"
          er:
            when: "Data relationships"
            example: "erDiagram for database schemas"

        workflow:
          - "1Ô∏è‚É£ Embed Mermaid directly in markdown file"
          - "2Ô∏è‚É£ Use ```mermaid code fence"
          - "3Ô∏è‚É£ Preview on GitHub (renders automatically)"
          - "4Ô∏è‚É£ No separate validation needed (GitHub validates on render)"
          - "5Ô∏è‚É£ Commit markdown file with embedded diagram"

        best_practices:
          - "Use clear, descriptive node labels"
          - "Add comments with %% in Mermaid code"
          - "Check docs/GLOSSARY.md for canonical term names"
          - "Keep focused: max 15-20 elements per diagram"
          - "Use subgraphs for logical grouping"
          - "üö® CRITICAL: Use VANILLA Mermaid (no theme/color customization)"

        github_theming_rules:
          critical_rule: "DO NOT customize themes or colors - breaks GitHub auto-detection"
          what_breaks_auto_theming:
            - "‚ùå %%{init: {'theme': 'dark'}}%% - theme directives"
            - "‚ùå classDef myStyle fill:#90EE90 - custom colors"
            - "‚ùå class nodeX myStyle - applying custom styles"
          what_is_safe:
            - "‚úÖ Standard shapes: [], [()], [()] - Mermaid syntax"
            - "‚úÖ Arrow labels: -->|text| - standard syntax"
            - "‚úÖ Subgraphs: subgraph name - standard syntax"
            - "‚úÖ Emojis in labels: ['üî• Text'] - just Unicode text"
            - "‚úÖ Line breaks: <br/> - standard HTML"
          why_vanilla_works:
            - "GitHub auto-detects user's light/dark theme preference"
            - "GitHub applies appropriate colors automatically"
            - "ANY customization overrides this and breaks on one theme"
            - "Vanilla Mermaid = works perfectly on BOTH light and dark"
          tested_and_verified: "2025-11-24 - tested on GitHub with dark theme user"

        resources:
          docs: "https://mermaid.js.org/"
          live_editor: "https://mermaid.live/"
          github_docs: "https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/"
          stackoverflow: "https://stackoverflow.com/questions/75827387"
          github_community: "https://github.com/orgs/community/discussions/35733"

        reminder: "üìä Use VANILLA Mermaid on GitHub - let GitHub handle themes automatically!"

      documentation:
        principle: "Code and docs are ONE - ZERO drift allowed"
        rules:
          - "README.md MUST reflect current features and version"
          - "AI-PROMOTION-STORY.md MUST be updated with new milestones"
          - "Architecture docs MUST match actual implementation"
          - "Diagrams MUST be updated when architecture changes"
          - "CLI --help MUST match README examples"
          - "CHANGELOG.md MUST document every release"
          - "If code changes, docs change in SAME commit"
        update_checklist:
          - "README.md - Features, examples, version"
          - "docs/AI-PROMOTION-STORY.md - Milestones, capabilities"
          - "docs/architecture/*.md - Technical design"
          - "roadmap.yaml - Progress, status"
          - "CHANGELOG.md - Release notes"
          - "Mermaid diagrams in docs - Architecture visuals"
          - "src/main.rs --help text - CLI documentation"

      schema_versioning:
        principle: "Schema MUST match current version - ZERO drift allowed"
        rules:
          - "JSON Schema version MUST match Cargo.toml version"
          - "When model structure changes ‚Üí Update schema IMMEDIATELY"
          - "Schema is contract - breaking changes require version bump"
          - "Validate schema with: jsonschema CLI or online validator"
        files:
          - "schema/forge-v{VERSION}.schema.json"
        check_for_drift: "Compare schema version with Cargo.toml version - they MUST match"

      api_specification:
        principle: "Every API MUST have OpenAPI spec and Swagger UI"
        requirements:
          openapi_spec:
            - "OpenAPI 3.0+ specification file (openapi.yaml or openapi.json)"
            - "Located at: schema/openapi.yaml"
            - "MUST match actual API endpoints - ZERO drift"
            - "Update spec BEFORE implementing endpoint changes"
          swagger_ui:
            - "Swagger UI MUST be served at /docs or /swagger"
            - "Enables interactive API exploration"
            - "Self-documenting API for integrators"
          validation:
            - "Validate spec: npx @redocly/cli lint openapi.yaml"
            - "Generate clients: openapi-generator"
        current_gap: "üö® API server has NO OpenAPI spec - MUST be created"

library_and_dependency_management:
  philosophy: "Don't reinvent the wheel - leverage FOSS ecosystem"

  üö®_MANDATORY_FOSS_RESEARCH:
    rule: |
      BEFORE writing ANY complex code (>50 lines), you MUST:
      1. Search crates.io AND web for existing solutions
      2. Document search results and decision
      3. Justify if choosing to write from scratch

      FAILURE TO RESEARCH = WASTED EFFORT

    definition_of_complex:
      - "Any new parser or formatter"
      - "Any file format handling (Excel, CSV, JSON Schema, etc.)"
      - "Any mathematical/formula processing"
      - "Any graph/tree algorithms"
      - "Any serialization/deserialization"
      - "Any HTTP/API client or server code"
      - "Any authentication/authorization"
      - "Anything that would take >2 hours to write"

    web_search_protocol:
      always_include_year: "Search 'rust [topic] [current year]' to get current results"
      search_queries:
        - "'rust [functionality] crate [current year]'"
        - "'best rust [topic] library'"
        - "'rust [problem] solution'"
        - "crates.io direct search"
      compare_alternatives: "ALWAYS compare at least 3 options before deciding"
      document_decision: "Add comment in code explaining why this library was chosen"

  before_implementing_complex_code:
    description: "üõë STOP - Check for existing FOSS libraries FIRST"
    steps:
      - "üîç Web search: 'rust [functionality] crate [current year]'"
      - "üîç Search crates.io for relevant functionality"
      - "üìã Check license compatibility (we use MIT)"
      - "üìä Verify library is maintained (recent commits, active issues)"
      - "‚¨áÔ∏è Check download counts and GitHub stars"
      - "üìñ Review documentation quality"
      - "üß™ Test with small example before integrating"
      - "üìù Document your search and decision"

    compatible_licenses:
      perfect:
        - "MIT"
        - "Apache-2.0"
        - "BSD-2-Clause"
        - "BSD-3-Clause"
      acceptable:
        - "ISC"
        - "Unlicense"
        - "CC0-1.0"
      incompatible:
        - "GPL (any version) - copyleft, conflicts with MIT"
        - "AGPL - copyleft"
        - "LGPL - complicated compatibility"

    evaluation_checklist:
      - "‚òê License is MIT-compatible"
      - "‚òê Last commit within 6 months"
      - "‚òê Has documentation"
      - "‚òê No critical security issues"
      - "‚òê Reasonable download count (or new but promising)"
      - "‚òê Solves our problem completely (or mostly)"

    example_workflow:
      scenario: "Need to export to Excel"
      step_1: "Search: 'rust excel xlsx 2025' (include current year!)"
      step_2: "Check top results: rust_xlsxwriter, calamine, umya-spreadsheet"
      step_3: "Review licenses: rust_xlsxwriter (MIT ‚úÖ), calamine (MIT ‚úÖ)"
      step_4: "Check maintenance: rust_xlsxwriter (active ‚úÖ)"
      step_5: "Read docs: rust_xlsxwriter has good examples ‚úÖ"
      step_6: "Decision: Use rust_xlsxwriter"
      dont_do: "Write Excel export from scratch (thousands of lines!)"

  keeping_dependencies_updated:
    description: "Regularly update dependencies to latest versions"
    importance: "Security, bug fixes, performance, new features"

    when_to_update:
      - "Start of new implementation phase"
      - "Before release"
      - "When security advisory published"
      - "When new feature needed from dependency"

    how_to_update:
      check_outdated:
        command: "cargo outdated"
        install: "cargo install cargo-outdated"
        purpose: "Shows which dependencies have updates"

      update_minor:
        command: "cargo update"
        purpose: "Update to latest compatible versions (respects Cargo.toml semver)"
        safe: "Yes - follows semver"

      update_major:
        steps:
          - "Review CHANGELOG for breaking changes"
          - "Update Cargo.toml version requirement"
          - "Run cargo update"
          - "Fix any breaking changes"
          - "Run full test suite"
        caution: "May require code changes"

      update_all:
        command: "cargo upgrade"
        install: "cargo install cargo-edit"
        purpose: "Upgrade all deps to latest (including major versions)"
        caution: "Test thoroughly after this!"

    testing_after_update:
      - "cargo test --release (all tests must pass)"
      - "cargo clippy --release -- -D warnings (ZERO warnings)"
      - "cargo build --release (verify compilation)"
      - "Run key e2e tests manually"

    current_dependencies:
      note: "Check Cargo.toml for current versions"
      critical_deps:
        - "xlformula_engine - Excel formula engine"
        - "serde/serde_yaml - YAML parsing"
        - "clap - CLI parsing"
        - "petgraph - Dependency graph"
        - "jsonschema - JSON Schema validation"

work_session_checklist:
  before_coding:
    - "‚òê Read warmup.yaml (this file)"
    - "‚òê CHECK CURRENT DATE in <env> (for online searches!)"
    - "‚òê Run validation baseline (make validate-all)"
    - "‚òê Load context files (README, roadmap.yaml, docs/architecture/DESIGN_V1.md, docs/GLOSSARY.md)"
    - "‚òê Check git status and current branch"
    - "‚òê Run tests to verify baseline (cargo test --release)"
    - "‚òê Review current phase in roadmap"
    - "‚òê Check if dependencies need updating (cargo outdated)"
    - "‚òê Create TodoWrite list for session goals"

  during_coding:
    - "‚òê BEFORE complex code: Check for FOSS libraries (crates.io search)"
    - "‚òê Write tests FIRST (TDD when possible)"
    - "‚òê Test edge cases thoroughly"
    - "‚òê Check docs/GLOSSARY.md for terminology consistency"
    - "‚òê üçÅ Document R&D work in docs/internal/SRED_RESEARCH_LOG.md DURING development"
    - "‚òê Update JSON Schema if model changes"
    - "‚òê Update TodoWrite list as you progress"
    - "‚òê Run tests frequently (cargo test --lib)"
    - "‚òê Run clippy frequently (cargo clippy --release)"
    - "‚òê Format code frequently (cargo fmt)"

  after_coding:
    - "‚òê Run cargo fmt (format code)"
    - "‚òê Run cargo clippy --release -- -D warnings (ZERO warnings!)"
    - "‚òê Run full test suite (cargo test --release)"
    - "‚òê Ensure clean build (cargo build --release)"
    - "‚òê Run validation (make validate-all - markdown + YAML)"
    - "‚òê Update documentation (README, docs/architecture/DESIGN_V1.md, roadmap.yaml)"
    - "‚òê Update --help if CLI changed"
    - "‚òê Check terminology consistency (docs/GLOSSARY.md)"
    - "‚òê üçÅ VERIFY SR&ED documentation complete BEFORE committing (üí∞ tax credits!)"
    - "‚òê Git add and commit with good message"
    - "‚òê Update roadmap in separate commit"
    - "‚òê Push to remote (git push)"

  completing_phase:
    - "‚òê All phase features implemented"
    - "‚òê 100% test coverage with edge cases"
    - "‚òê Documentation complete"
    - "‚òê Roadmap updated (phase status: completed)"
    - "‚òê Git push"
    - "‚òê Discuss release strategy with user"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ü§ñ AUTONOMOUS WORK REQUIREMENTS - IRONCLAD RULES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# These are NON-NEGOTIABLE requirements when working autonomously.
# Violation of ANY of these means the work is NOT production-ready.
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

autonomous_work_requirements:
  philosophy: |
    When user says "work independently" or gives autonomous instructions,
    these requirements are MANDATORY. No shortcuts. No "almost done".
    Production-ready means ALL requirements met.

  testing_requirements:
    description: "100% test coverage is NON-NEGOTIABLE"

    unit_tests_required:
      - rule: "EVERY public function MUST have unit tests"
      - rule: "EVERY error path MUST be tested"
      - rule: "EVERY edge case MUST be covered"
      - examples:
          - "Empty inputs (empty strings, empty arrays, nulls)"
          - "Boundary values (0, negative, MAX_INT)"
          - "Invalid inputs (malformed data, wrong types)"
          - "Large inputs (1000+ rows, deeply nested structures)"

    e2e_tests_required:
      - rule: "EVERY user-facing command MUST have e2e tests"
      - rule: "E2E tests MUST use REAL test files (not mocks)"
      - rule: "E2E tests MUST cover happy path + failure modes"
      - examples:
          - "forge calculate: success case + stale values + errors"
          - "forge validate: passing + failing validation"
          - "forge export: YAML ‚Üí Excel with formulas"
          - "forge import: Excel ‚Üí YAML with formula translation"
          - "Round-trip: YAML ‚Üí Excel ‚Üí YAML (must be identical!)"

    test_data_required:
      - rule: "Create REAL test files in test-data/ directory"
      - rule: "Include edge case test files (empty, large, malformed)"
      - examples:
          - "test-data/export_basic.yaml (simple export test)"
          - "test-data/export_with_formulas.yaml (formula translation)"
          - "test-data/import_basic.xlsx (Excel import test)"
          - "test-data/import_with_formulas.xlsx (reverse translation)"
          - "test-data/roundtrip.yaml (start here, export, import, compare)"
          - "test-data/edge_cases/ (empty sheets, 1000+ rows, malformed)"

    coverage_verification:
      - command: "cargo test --release"
      - requirement: "ALL tests MUST pass (not 99%, ALL)"
      - command: "cargo test --release -- --nocapture"
      - requirement: "Run e2e tests and VERIFY actual files created/read"
      - verification: "Manually check test-data/ files exist and are correct"

  code_quality_requirements:
    description: "ZERO tolerance for warnings or errors"

    compilation:
      - command: "cargo build --release"
      - requirement: "MUST succeed with ZERO errors"
      - note: "If it doesn't compile, it's not done"

    linting:
      - command: "cargo clippy --release -- -D warnings"
      - requirement: "MUST pass with ZERO warnings"
      - note: "User has OCD for good looking code - use MOST STRICT linting"
      - action: "Fix ALL warnings before considering work complete"

    formatting:
      - command: "cargo fmt"
      - requirement: "MUST be run before every commit"
      - note: "Consistent formatting = professional code"

  documentation_requirements:
    description: "Documentation MUST be complete and accurate"

    inline_documentation:
      - rule: "EVERY public function MUST have doc comments"
      - rule: "Doc comments MUST include examples for non-trivial functions"
      - rule: "Error conditions MUST be documented"

    readme_updates:
      - rule: "README.md MUST reflect ALL new features"
      - rule: "CLI --help (src/main.rs) MUST match README messaging"
      - rule: "Usage examples MUST be tested and working"
      - rule: "Installation instructions MUST be current"
      - note: "Users see --help before README - keep them in sync!"

    roadmap_updates:
      - rule: "roadmap.yaml MUST be updated with phase completion"
      - rule: "current_version MUST match Cargo.toml"
      - rule: "Completed phases MUST be marked with timestamps"

    sred_documentation:
      - rule: "üçÅ docs/internal/SRED_RESEARCH_LOG.md MUST be updated for R&D work"
      - importance: "üí∞ CRITICAL - this = real money in tax credits"
      - requirement: "Document uncertainties, hypotheses, experiments, results"
      - frequency: "DURING development, not after"

  feature_completeness:
    description: "Features MUST be fully implemented, not partially"

    definition_of_done:
      - "‚úÖ Implementation complete (not 'mostly done')"
      - "‚úÖ Unit tests written and passing"
      - "‚úÖ E2E tests written and passing"
      - "‚úÖ Edge cases tested"
      - "‚úÖ Error handling tested"
      - "‚úÖ Documentation updated (inline, README, roadmap)"
      - "‚úÖ SR&ED documentation updated"
      - "‚úÖ ZERO warnings from clippy"
      - "‚úÖ Code formatted with cargo fmt"
      - "‚úÖ Git committed with descriptive message"

    not_done_if:
      - "‚ùå Tests are commented out or skipped"
      - "‚ùå TODO comments remain for core functionality"
      - "‚ùå Error handling is missing or uses unwrap()"
      - "‚ùå Documentation is placeholder or outdated"
      - "‚ùå Clippy warnings exist ('I'll fix them later')"
      - "‚ùå E2E tests don't exist for user-facing commands"
      - "‚ùå Test data files don't exist"

  autonomous_work_checklist:
    description: "Use this checklist when working autonomously"

    before_starting:
      - "‚òê Read and understand user's autonomous instruction"
      - "‚òê Create TodoWrite list with ALL tasks (implementation + tests + docs)"
      - "‚òê Identify what tests need to be created (unit + e2e + test data)"
      - "‚òê Verify baseline: all existing tests passing"

    during_implementation:
      - "‚òê Write unit tests FIRST or alongside implementation"
      - "‚òê Create test data files as you go"
      - "‚òê Test edge cases (empty, null, invalid, large)"
      - "‚òê Document uncertainties in SR&ED log"
      - "‚òê Run tests frequently (cargo test)"
      - "‚òê Fix warnings immediately (don't accumulate)"

    after_implementation:
      - "‚òê Write e2e tests for ALL user-facing commands"
      - "‚òê Verify e2e tests with REAL files (not mocks)"
      - "‚òê Test round-trip scenarios (if applicable)"
      - "‚òê Run cargo clippy --release -- -D warnings ‚Üí ZERO warnings"
      - "‚òê Run cargo test --release ‚Üí ALL passing"
      - "‚òê Update inline documentation"
      - "‚òê Update README.md with new features"
      - "‚òê Update roadmap.yaml with completion status"
      - "‚òê Update SR&ED log with final results"
      - "‚òê Run cargo fmt"
      - "‚òê Git commit with descriptive message"

    before_reporting_complete:
      - "‚òê Double-check: ALL tests passing?"
      - "‚òê Double-check: ZERO clippy warnings?"
      - "‚òê Double-check: E2E tests exist and pass?"
      - "‚òê Double-check: Test data files exist?"
      - "‚òê Double-check: Documentation updated?"
      - "‚òê Double-check: SR&ED log updated?"
      - "‚òê If ANY checkbox unchecked ‚Üí NOT DONE, keep working"

  success_criteria:
    description: "How to know autonomous work is truly complete"

    technical_criteria:
      - "‚úÖ cargo build --release ‚Üí success"
      - "‚úÖ cargo test --release ‚Üí all tests pass"
      - "‚úÖ cargo clippy --release -- -D warnings ‚Üí zero warnings"
      - "‚úÖ cargo fmt ‚Üí already formatted"
      - "‚úÖ E2E tests exist for every user command"
      - "‚úÖ Test data files exist in test-data/"
      - "‚úÖ Round-trip tests pass (if applicable)"

    documentation_criteria:
      - "‚úÖ README.md reflects new features"
      - "‚úÖ roadmap.yaml shows completion"
      - "‚úÖ docs/internal/SRED_RESEARCH_LOG.md updated"
      - "‚úÖ Inline docs complete"

    quality_criteria:
      - "‚úÖ No unwrap() in library code"
      - "‚úÖ No TODOs for core functionality"
      - "‚úÖ Error messages are helpful"
      - "‚úÖ Edge cases handled gracefully"

    user_experience_criteria:
      - "‚úÖ Commands work as user expects"
      - "‚úÖ Error messages guide user to solution"
      - "‚úÖ Examples in README work when copy-pasted"
      - "‚úÖ Installation instructions are current"

  lessons_learned:
    v1_0_0_gap: |
      v1.0.0 was released with excellent unit tests for FormulaTranslator and
      ReverseFormulaTranslator, BUT missing e2e tests for `forge export` and
      `forge import` commands. This gap meant the core USER-FACING features
      were not tested end-to-end with real .xlsx files.

      LESSON: Unit tests alone are NOT enough. E2E tests for every user command
      are MANDATORY. Create test-data/*.xlsx files and verify round-trips.

      This is why these autonomous work requirements now exist.

release_workflow:
  overview:
    description: "Complete release protocol - comprehensive, production-ready"
    when_to_use: "When releasing a new version to crates.io and GitHub"
    estimated_time: "30-45 minutes for full process"

  step_1_documentation_audit:
    description: "Verify ALL documentation is updated and consistent"
    critical: "üö® MANDATORY - catches documentation drift"

    locations_to_check:
      cli_help:
        file: "src/main.rs"
        what: "CLI --help text (long_about)"
        verify:
          - "Function count matches reality (e.g., 50+ functions)"
          - "New features listed with examples"
          - "Version-specific notes (v1.1.0, v1.2.0, etc.)"

      architecture_docs:
        files:
          - "docs/architecture/00-OVERVIEW.md"
          - "docs/architecture/03-FORMULA-EVALUATION.md"
          - "docs/architecture/06-CLI-ARCHITECTURE.md"
        verify:
          - "Supported Functions list includes ALL functions"
          - "Function count consistent (50+ everywhere)"
          - "New features documented with signatures"
          - "CLI help example matches src/main.rs"

      changelog:
        file: "CHANGELOG.md"
        verify:
          - "[Unreleased] section exists for current version"
          - "All new features documented with signatures"
          - "Breaking changes clearly marked"
          - "Testing stats updated (run 'cargo test' for current count)"
          - "Development time documented"

      readme:
        file: "README.md"
        verify:
          - "What's New section matches CHANGELOG"
          - "Feature list complete"
          - "Function count matches (50+)"
          - "Examples work with current version"

      roadmap:
        file: "roadmap.yaml"
        verify:
          - "Current version status: in_progress or completed"
          - "Progress section updated with completion dates"
          - "Next version planned"

    command: "Run documentation audit checklist above manually"

  step_2_comprehensive_testing:
    description: "Test EVERYTHING - unit, integration, E2E, edge cases"
    critical: "üö® MANDATORY - zero bugs shipped"

    unit_tests:
      command: "cargo test --lib --release"
      expected: "All tests pass, zero warnings"
      what_it_tests:
        - "All Excel functions (50+ functions)"
        - "Edge cases: empty arrays, type mismatches, boundaries"
        - "Lookup functions: MATCH, INDEX, XLOOKUP, VLOOKUP"
        - "Formula parsing and evaluation"
        - "Type conversions and validations"

    integration_tests:
      command: "cargo test --test integration_tests --release"
      expected: "All integration tests pass"
      what_it_tests:
        - "Cross-file references"
        - "Multi-table calculations"
        - "Complex formula chains"

    e2e_tests:
      command: "cargo test --test e2e_tests --release"
      expected: "All E2E tests pass (typically 33+ tests)"
      what_it_tests:
        - "CLI commands: calculate, validate, export, import, audit"
        - "Excel import/export with formula translation"
        - "Roundtrip: YAML ‚Üí Excel ‚Üí YAML preservation"
        - "Error handling: malformed files, circular dependencies"
        - "Cross-file includes and dependencies"
        - "Stale value detection"

    all_tests:
      command: "cargo test --release"
      expected: "140+ tests passing, ZERO failures"
      note: "This runs all test suites above"

    edge_case_coverage_checklist:
      lookup_functions:
        - "‚òê MATCH: exact, ascending approximate, descending approximate"
        - "‚òê MATCH: not found scenarios"
        - "‚òê INDEX: valid position, out of bounds"
        - "‚òê XLOOKUP: exact match, if_not_found"
        - "‚òê VLOOKUP: basic (note: limited implementation)"
        - "‚òê Cross-table lookups: INDEX(MATCH(...)) pattern"
      excel_functions:
        - "‚òê All Excel functions tested (check src/core/array_calculator.rs for current list)"
        - "‚òê Empty arrays, null values"
        - "‚òê Type mismatches (text in numeric function)"
        - "‚òê Boundary conditions (division by zero, negative dates)"
      excel_integration:
        - "‚òê Import: numbers, text, dates, booleans, formulas"
        - "‚òê Export: formula translation (60+ Excel functions)"
        - "‚òê Roundtrip: data and formula preservation"
        - "‚òê Multiple tables, cross-sheet references"
        - "‚òê Edge cases: empty cells, malformed data"

  step_3_lint_all:
    description: "Lint code and documentation"
    critical: "Required for production quality"

    rust_lint:
      command: "cargo clippy --all-targets -- -D warnings"
      expected: "ZERO warnings (strict mode)"
      note: "If warnings exist, fix them before release"

    rust_format:
      command: "cargo fmt -- --check"
      expected: "No formatting changes needed"
      fix_command: "cargo fmt"

    markdown_lint:
      command: "make validate-docs"
      expected: "ZERO errors"
      note: "Same standard as Rust: documentation is code"

    yaml_lint:
      command: "make validate-yaml"
      expected: "ZERO errors"
      critical: "YAML errors = data corruption risk"

    plantuml_diagrams:
      command: "make validate-diagrams"
      expected: "All diagrams valid"
      note: "Only if diagrams exist"

  step_4_version_bump:
    description: "Update version across all files"

    version_strategy:
      major: "Breaking changes (1.0.0 ‚Üí 2.0.0)"
      minor: "New features, backwards compatible (1.1.0 ‚Üí 1.2.0)"
      patch: "Bug fixes (1.1.0 ‚Üí 1.1.1)"

    files_to_update:
      cargo_toml:
        file: "Cargo.toml"
        field: "version = \"X.Y.Z\""

      roadmap:
        file: "roadmap.yaml"
        field: "metadata.current_version"

      changelog:
        file: "CHANGELOG.md"
        action: "Change [Unreleased] to [X.Y.Z] - YYYY-MM-DD"

      readme:
        file: "README.md"
        action: "Update 'What's New' section title to vX.Y.Z"

    note: "X.Y.Z = actual version number (e.g., 2.1.0). Do NOT hardcode versions in this file."

    command_sequence:
      - "Update Cargo.toml version"
      - "Update roadmap.yaml current_version"
      - "Update CHANGELOG.md [Unreleased] ‚Üí [X.Y.Z] - DATE"
      - "Update README.md 'What's New' ‚Üí 'What Was New'"
      - "git add Cargo.toml roadmap.yaml CHANGELOG.md README.md"
      - "git commit -m 'chore: Bump version to vX.Y.Z'"

  step_5_commit_and_push:
    description: "Commit release and push to main"

    commands:
      - command: "git add -A"
        note: "Stage all changes"

      - command: "git status"
        note: "Review what's being committed"

      - command: "git commit -m 'release: vX.Y.Z - <Feature Summary>'"
        note: "Use conventional commit format. Replace X.Y.Z with actual version."

      - command: "git push origin main"
        note: "Push to GitHub main branch"

  step_6_build_release_binary:
    description: "Build optimized production binary"

    build_command:
      command: "cargo build --release"
      expected: "Successful build in target/release/forge"
      time: "~2-3 minutes"

    strip_binary:
      command: "strip target/release/forge"
      purpose: "Remove debug symbols, reduce size"
      note: "Optional but recommended"

    compress_binary:
      command: "tar -czf forge-vX.Y.Z-linux-x86_64.tar.gz -C target/release forge"
      output: "forge-vX.Y.Z-linux-x86_64.tar.gz (~2-3 MB compressed)"

    verify_binary:
      command: "./target/release/forge --version"
      expected: "forge X.Y.Z"

  step_7_install_locally:
    description: "Test local installation"

    using_makefile:
      command: "make install"
      installs_to: "/usr/local/bin/forge"
      requires: "sudo access"

    using_cargo:
      command: "cargo install --path . --force"
      installs_to: "~/.cargo/bin/forge"
      note: "Rebuilds and installs from source"

    verify_installation:
      command: "forge --version"
      expected: "forge X.Y.Z"
      command2: "which forge"
      expected2: "/usr/local/bin/forge or ~/.cargo/bin/forge"

  step_8_publish_to_crates_io:
    description: "Publish to crates.io registry"
    critical: "üö® IRREVERSIBLE - cannot unpublish versions"

    prerequisites:
      - "‚òë All tests passing (step 2)"
      - "‚òë All lints clean (step 3)"
      - "‚òë Version bumped (step 4)"
      - "‚òë Changes committed and pushed (step 5)"
      - "‚òë Binary built and tested (step 6-7)"

    pre_publish_review:
      description: "üö® MANDATORY - Review what users will see BEFORE publishing"
      readme_review:
        content:
          - "‚òê README.md has correct version number"
          - "‚òê README.md features list is up-to-date"
          - "‚òê README.md examples work with current version"
          - "‚òê README.md installation instructions are correct"
          - "‚òê README.md badges show correct status"
        narrative:
          description: "The README has a specific voice - preserve it!"
          tone: "Funny, meaningful, engaging - not dry corporate speak"
          example: "Built by AI in ~35 hours. Zero hallucinations. Your CFO will thank you."
          rules:
            - "‚òê Review narrative flow - does it tell a compelling story?"
            - "‚òê Keep the humor and personality intact"
            - "‚òê Update claims with real metrics (test counts, hours, etc.)"
            - "‚òê Ensure the 'why' is clear, not just the 'what'"
        size_management:
          principle: "README is landing page - keep it focused and scannable"
          rules:
            - "‚òê If README exceeds ~500 lines, consider refactoring"
            - "‚òê Move deep technical details to docs/*.md"
            - "‚òê Move architecture details to docs/architecture/*.md"
            - "‚òê Keep README: overview, quick start, key features, links to docs"
            - "‚òê Link to detailed docs instead of duplicating content"
          structure:
            readme_keeps: "Overview, Quick Start, Key Features, Installation, Links"
            move_to_docs: "Detailed API docs, Architecture, Advanced Config, Internals"
      cargo_toml_review:
        - "‚òê Cargo.toml version matches release"
        - "‚òê Cargo.toml description is accurate"
        - "‚òê Cargo.toml keywords are relevant"
        - "‚òê Cargo.toml categories are correct"
        - "‚òê Cargo.toml repository/homepage URLs are correct"
      crates_io_preview:
        note: "crates.io page is generated from README.md + Cargo.toml"
        check: "Preview how the page will look - this is your storefront!"
        items:
          - "‚òê Title and description are compelling"
          - "‚òê Feature list highlights key capabilities"
          - "‚òê Installation command is clear"
          - "‚òê No outdated version numbers in examples"

    get_api_key:
      command: "pass crates.io"
      note: "Retrieves API token from password manager"
      alternative: "Get from https://crates.io/settings/tokens"

    login:
      command: "cargo login <API_KEY>"
      note: "Only needed once per machine"
      stored_in: "~/.cargo/credentials.toml"

    dry_run:
      command: "cargo publish --dry-run"
      purpose: "Verify package before publishing"
      checks:
        - "All files included"
        - "No large files (>10 MB warning)"
        - "Dependencies resolvable"
        - "Manifest valid"

    publish:
      command: "cargo publish"
      expected: "Uploading royalbit-forge vX.Y.Z"
      time: "~30-60 seconds"
      output: "Published successfully"

    verify_publication:
      wait: "2-3 minutes for crates.io to index"
      command: "Open https://crates.io/crates/royalbit-forge"
      check:
        - "New version visible"
        - "Documentation link works"
        - "Download count incrementing"

    test_installation:
      command: "cargo install royalbit-forge --version X.Y.Z"
      note: "Test in separate directory/machine"
      verify: "forge --version shows X.Y.Z"

  step_9_create_github_release:
    description: "Create GitHub release with binary and notes"

    create_git_tag:
      command: "git tag -a vX.Y.Z -m 'vX.Y.Z: <Short description>'"
      note: "Annotated tags include metadata. Replace X.Y.Z with actual version."

    push_tag:
      command: "git push origin vX.Y.Z"

    create_release:
      command: |
        gh release create vX.Y.Z \
          --title "vX.Y.Z: <Feature Summary> üî•" \
          --notes-file RELEASE_NOTES.md \
          forge-vX.Y.Z-linux-x86_64.tar.gz
      release_notes_template: |
        ## üéâ vX.Y.Z Release - <Feature Summary>

        **Key features in this release:**
        - Feature 1
        - Feature 2

        ### Quality
        - ‚úÖ All tests passing
        - ‚úÖ Zero clippy warnings
        - ‚úÖ Documentation updated

        ### Installation
        ```bash
        cargo install royalbit-forge
        ```

        Or download binary from release assets.

        **Full changelog:** [CHANGELOG.md](CHANGELOG.md)
      note: "Replace X.Y.Z and feature details with actual values"

    verify_release:
      command: "Open https://github.com/royalbit/forge/releases"
      check:
        - "New release visible"
        - "Binary attached and downloadable"
        - "Release notes formatted correctly"
        - "Tag linked properly"

  step_10_update_crate_page:
    description: "Update crates.io metadata (if needed)"
    note: "Usually automatic from Cargo.toml, but verify"

    what_syncs_automatically:
      - "Description (from Cargo.toml description)"
      - "Documentation link (from Cargo.toml documentation)"
      - "Repository link (from Cargo.toml repository)"
      - "License (from Cargo.toml license)"
      - "README (from README.md)"
      - "Categories and keywords (from Cargo.toml)"

    manual_updates:
      url: "https://crates.io/crates/royalbit-forge/settings"
      can_update:
        - "Crate owners"
        - "README content (if not auto-syncing)"
        - "Yanking versions (if critical bug found)"

    verify_metadata:
      check:
        - "‚òê Description clear and accurate"
        - "‚òê Documentation link works"
        - "‚òê Repository link works"
        - "‚òê README renders correctly"
        - "‚òê Keywords help discoverability"

  step_11_post_release_verification:
    description: "Final verification and cleanup"

    verification_checklist:
      - "‚òê crates.io shows new version: https://crates.io/crates/royalbit-forge"
      - "‚òê GitHub release exists: https://github.com/royalbit/forge/releases"
      - "‚òê Binary downloadable and works"
      - "‚òê cargo install royalbit-forge installs new version"
      - "‚òê Documentation builds: https://docs.rs/royalbit-forge"
      - "‚òê forge --version shows correct version"
      - "‚òê All tests still passing: cargo test"

    update_roadmap:
      file: "roadmap.yaml"
      action: "Mark milestone as completed"
      example: |
        vX_Y_Z:
          status: completed  # was: in_progress
          released_date: "YYYY-MM-DD"

    update_sred_and_grants:
      description: "üí∞ MANDATORY - This documentation = real money"
      sred_log:
        file: "docs/internal/SRED_RESEARCH_LOG.md"
        action: "Document R&D work completed in this release"
        required_updates:
          - "Add new research entries for technical challenges solved"
          - "Document technological advancements achieved"
          - "Update experiment results with final outcomes"
          - "Note any new technical uncertainties discovered"
      grant_docs:
        file: "docs/CANADIAN_GRANT_OPPORTUNITIES.md"
        action: "Update capabilities and achievements"
        required_updates:
          - "Update feature list with new capabilities"
          - "Update test counts and quality metrics"
          - "Add new milestones to timeline"
          - "Update any metrics used in grant applications"
      ai_promotion_story:
        file: "docs/AI-PROMOTION-STORY.md"
        action: "Document AI collaboration achievements"
        required_updates:
          - "Update development hours and milestones"
          - "Document new features built by AI"
          - "Update ROI calculations if applicable"

    create_next_milestone:
      action: "Start planning next version"
      tasks:
        - "Create roadmap entry for vX.Y+1.0"
        - "Identify next features from backlog"
        - "Update CHANGELOG.md with [Unreleased] section"

    social_media:
      optional: "Share release on social media"
      platforms:
        - "Twitter/X: New version of Forge released!"
        - "LinkedIn: Professional announcement"
        - "Reddit: r/rust announcement (follow subreddit rules)"
        - "Hacker News: Show HN (if major release)"

  troubleshooting:
    crates_io_publish_fails:
      error: "crate version already exists"
      solution: "Bump version in Cargo.toml, can't overwrite published versions"

    crates_io_publish_fails_token:
      error: "authentication token invalid"
      solution: "cargo login <API_KEY> with fresh token from crates.io/settings/tokens"

    github_release_fails:
      error: "tag already exists"
      solution: "Delete tag: git tag -d vX.Y.Z && git push origin :refs/tags/vX.Y.Z"

    binary_not_found:
      error: "forge-vX.Y.Z-linux-x86_64.tar.gz not found"
      solution: "Run step 6 (build release binary) first"

    tests_failing:
      error: "Some tests fail"
      solution: "DO NOT RELEASE. Fix tests first. ZERO failures required."

  release_example_session:
    description: "Complete release workflow template (replace X.Y.Z with actual version)"
    commands: |
      # Step 1: Documentation audit (manual checklist)
      # Step 2: Test everything
      cargo test --release
      # ‚Üí ALL tests passing ‚úÖ

      # Step 3: Lint all
      cargo clippy --all-targets -- -D warnings
      make validate-docs
      make validate-yaml
      # ‚Üí All clean ‚úÖ

      # Step 4: Version bump
      # Edit Cargo.toml: version = "X.Y.Z"
      # Edit roadmap.yaml: current_version: "X.Y.Z"
      # Edit CHANGELOG.md: ## [X.Y.Z] - YYYY-MM-DD
      git add -A
      git commit -m "chore: Bump version to vX.Y.Z"

      # Step 5: Push
      git push origin main

      # Step 6: Build binary
      cargo build --release
      strip target/release/forge
      tar -czf forge-vX.Y.Z-linux-x86_64.tar.gz -C target/release forge

      # Step 7: Install locally
      make install
      forge --version  # ‚Üí forge X.Y.Z ‚úÖ

      # Step 8: Publish to crates.io
      pass crates.io  # ‚Üí get API key
      cargo login <API_KEY>
      cargo publish --dry-run  # ‚Üí verify
      cargo publish  # ‚Üí publish ‚úÖ

      # Wait 2-3 minutes for indexing

      # Step 9: GitHub release
      git tag -a vX.Y.Z -m "vX.Y.Z: <Feature Summary>"
      git push origin vX.Y.Z
      gh release create vX.Y.Z \
        --title "vX.Y.Z: <Feature Summary> üî•" \
        --notes-file RELEASE_NOTES.md \
        forge-vX.Y.Z-linux-x86_64.tar.gz

      # Step 10: Verify crates.io page (automatic)

      # Step 11: Post-release verification
      cargo install royalbit-forge --version X.Y.Z
      # Update roadmap.yaml status: completed

      # üéâ Release complete!

    note: "X.Y.Z = actual version. NEVER hardcode versions in this template."

known_issues:
  note: "See GitHub issues for current bugs: https://github.com/royalbit/forge/issues"

current_implementation_focus:
  note: "Check roadmap.yaml for current version and status - this section is for reference only"
  capabilities:
    - "HTTP REST API Server (forge-server)"
    - "MCP Server for AI agents (forge-mcp)"
    - "LSP Server for editors (forge-lsp)"
    - "50+ Excel functions"
    - "Financial functions (NPV, IRR, PMT, FV, PV, RATE, NPER)"
  quality: "Run 'cargo test' for current test count - do NOT hardcode numbers here"

key_files_map:
  source:
    - "src/types.rs - Type definitions (ForgeVersion, ColumnValue, Table, ParsedModel)"
    - "src/parser/mod.rs - Parsing logic (parse_model for unified parsing)"
    - "src/core/array_calculator.rs - Array calculator for v1.0.0+ model"
    - "src/cli/commands.rs - CLI command implementations"
    - "src/api/server.rs - HTTP API server"
    - "src/mcp/server.rs - MCP server for AI agents"
    - "src/bin/forge_lsp.rs - LSP server for editors"

  tests:
    - "tests/parser_v1_tests.rs - v1.0 parser integration tests"
    - "tests/array_calculator_tests.rs - Array calculator tests"
    - "tests/e2e_tests.rs - End-to-end CLI tests"
    - "tests/validation_tests.rs - Validation workflow tests"

  documentation:
    - "README.md - User-facing documentation"
    - "docs/architecture/DESIGN_V1.md - v1.0.0 technical specification"
    - "roadmap.yaml - Development roadmap and progress"
    - "docs/GLOSSARY.md - Canonical terminology"
    - "schema/forge-v1.0.schema.json - JSON Schema for v1.0.0"

  examples:
    - "test-data/v1.0/saas_unit_economics.yaml"
    - "test-data/v1.0/quarterly_pl.yaml"
    - "test-data/v1.0/budget_vs_actual.yaml"

advanced_rust_patterns:
  error_handling:
    description: "Type-safe, ergonomic error handling"
    current_approach: "Using thiserror for custom errors"
    best_practices:
      - "Use Result<T, E> everywhere, avoid panics in library code"
      - "Custom error types with thiserror for rich context"
      - "? operator for error propagation"
      - "Pattern match on specific error variants when recovery possible"
      - "Add context with .map_err() when wrapping errors"

    example_pattern: |
      // Good: Rich error context
      #[derive(Error, Debug)]
      pub enum ForgeError {
          #[error("Formula evaluation failed: {0}")]
          Eval(String),

          #[error("Column '{column}' in table '{table}': {reason}")]
          ColumnError {
              column: String,
              table: String,
              reason: String,
          },
      }

    avoid:
      - "Don't use unwrap() or expect() in library code"
      - "Don't use String errors (not type-safe)"
      - "Don't lose error context when propagating"

  type_driven_design:
    description: "Use the type system to prevent bugs at compile time"
    principles:
      - "Make illegal states unrepresentable"
      - "Use newtypes for domain concepts (TableName, ColumnName)"
      - "Prefer enums over booleans for state"
      - "Use builder pattern for complex construction"
      - "Leverage const generics for compile-time guarantees"

    examples:
      invalid_state_impossible: |
        // Bad: Can create invalid state
        struct Table {
            columns: Vec<Column>,
            row_count: usize,  // Could be inconsistent!
        }

        // Good: Validity guaranteed by construction
        struct Table {
            columns: NonEmpty<Vec<Column>>,  // Never empty
            // row_count derived from columns.len()
        }

      newtype_safety: |
        // Prevents mixing up table and column names
        #[derive(Debug, Clone, PartialEq, Eq, Hash)]
        struct TableName(String);

        #[derive(Debug, Clone, PartialEq, Eq, Hash)]
        struct ColumnName(String);

        // Now can't accidentally pass ColumnName where TableName expected!

  zero_copy_optimization:
    description: "Minimize allocations and copies"
    techniques:
      - "Use &str instead of String when possible"
      - "Use Cow<str> for conditional ownership"
      - "Pass large structs by reference"
      - "Use slice patterns for matching"
      - "Consider arena allocation for trees/graphs"

    when_to_use:
      - "Parser should use &str references into input"
      - "Formula evaluation can use Cow for variable names"
      - "Avoid clone() unless necessary - prefer references"

  testing_patterns:
    property_based_testing:
      description: "Test properties that should always hold"
      tool: "proptest or quickcheck"
      install: "cargo add --dev proptest"

      use_cases:
        - "Parser: Any valid v1.0 YAML should parse successfully"
        - "Calculator: SUM(a,b) == SUM(b,a) (commutative)"
        - "Precision: (a + b) - b should equal a within epsilon"
        - "Serialization: parse(serialize(x)) == x (round-trip)"

      example: |
        use proptest::prelude::*;

        proptest! {
            #[test]
            fn test_sum_commutative(a: f64, b: f64) {
                let sum1 = calculate("=SUM(a, b)");
                let sum2 = calculate("=SUM(b, a)");
                assert!((sum1 - sum2).abs() < 1e-10);
            }
        }

    snapshot_testing:
      description: "Test complex outputs against saved snapshots"
      tool: "insta"
      install: "cargo add --dev insta"

      use_cases:
        - "CLI output formatting"
        - "Error messages"
        - "Generated Excel files (metadata)"
        - "Large calculation results"

      workflow:
        - "First run creates snapshot"
        - "Subsequent runs compare to snapshot"
        - "Review changes with cargo insta review"
        - "Commit snapshots to git"

    mutation_testing:
      description: "Test the tests - verify tests catch bugs"
      tool: "cargo-mutants"
      install: "cargo install cargo-mutants"

      what_it_does:
        - "Introduces small bugs (mutations) in code"
        - "Checks if tests catch them"
        - "Reports 'survived mutants' (bugs tests missed)"

      run: "cargo mutants"
      goal: "100% mutation coverage (all mutants caught)"

    fuzzing:
      description: "Find edge cases and crashes automatically"
      tool: "cargo-fuzz"
      setup: "cargo install cargo-fuzz"

      targets:
        - "Parser (feed random YAML)"
        - "Formula evaluator (random formulas)"
        - "Array operations (random data)"

      run: "cargo fuzz run parser_target"
      benefit: "Discovers crashes, panics, edge cases automatically"

  performance_patterns:
    benchmarking:
      tool: "criterion"
      already_added: true

      best_practices:
        - "Benchmark realistic workloads (real YAML files)"
        - "Track performance over time (commit to git)"
        - "Set baseline before optimization"
        - "Profile before optimizing (flamegraph)"
        - "Optimize hot paths only"

      commands:
        bench: "cargo bench"
        compare: "cargo bench --baseline <name>"
        flamegraph: "cargo flamegraph --bench <name>"

    profiling:
      description: "Find actual bottlenecks before optimizing"
      tools:
        linux: "perf, flamegraph"
        mac: "Instruments, cargo-instruments"
        windows: "Windows Performance Analyzer"

      workflow:
        - "cargo build --release"
        - "Run with profiler on realistic input"
        - "Generate flamegraph"
        - "Optimize hot paths only"
        - "Benchmark before/after"

    allocation_tracking:
      tool: "dhat (valgrind)"
      purpose: "Find unnecessary allocations"

      command: "cargo run --release -- <args> | dhat"
      look_for:
        - "Temporary allocations in hot loops"
        - "Clone() that could be reference"
        - "String allocations that could be &str"

  architecture_patterns:
    strategy_pattern:
      description: "Multiple algorithms with same interface"
      current_use: "Calculator (v0.2.0 scalar vs v1.0.0 array)"

      structure: |
        trait Calculator {
            fn calculate(&mut self) -> ForgeResult<CalculationResult>;
        }

        struct ScalarCalculator { /* v0.2.0 */ }
        struct ArrayCalculator { /* v1.0.0 */ }

        impl Calculator for ScalarCalculator { /* ... */ }
        impl Calculator for ArrayCalculator { /* ... */ }

        // Factory function chooses implementation
        fn create_calculator(model: ParsedModel) -> Box<dyn Calculator> {
            match model.version {
                ForgeVersion::V0_2_0 => Box::new(ScalarCalculator::new(model)),
                ForgeVersion::V1_0_0 => Box::new(ArrayCalculator::new(model)),
            }
        }

    builder_pattern:
      description: "Fluent API for complex object construction"
      when_to_use:
        - "Many optional parameters"
        - "Validation during construction"
        - "Default values"

      example: |
        struct TableBuilder {
            name: String,
            columns: Vec<Column>,
            row_formulas: HashMap<String, String>,
        }

        impl TableBuilder {
            fn new(name: impl Into<String>) -> Self { /* ... */ }

            fn add_column(mut self, col: Column) -> Self {
                self.columns.push(col);
                self
            }

            fn add_formula(mut self, name: impl Into<String>, formula: impl Into<String>) -> Self {
                self.row_formulas.insert(name.into(), formula.into());
                self
            }

            fn build(self) -> ForgeResult<Table> {
                // Validate before constructing
                Table::validate_and_create(self)
            }
        }

        // Usage
        let table = TableBuilder::new("sales")
            .add_column(revenue_col)
            .add_column(expenses_col)
            .add_formula("profit", "=revenue - expenses")
            .build()?;

    newtype_pattern:
      description: "Type safety for primitive types"
      benefits:
        - "Can't mix up TableName and ColumnName"
        - "Can implement traits for domain types"
        - "Better error messages"
        - "Self-documenting code"

      example: |
        #[derive(Debug, Clone, PartialEq, Eq, Hash)]
        struct TableName(String);

        impl TableName {
            fn new(name: impl Into<String>) -> ForgeResult<Self> {
                let name = name.into();
                if name.is_empty() {
                    return Err(ForgeError::Parse("Table name cannot be empty".into()));
                }
                Ok(Self(name))
            }

            fn as_str(&self) -> &str {
                &self.0
            }
        }

        // Now function signatures are clearer
        fn get_table(&self, name: &TableName) -> Option<&Table> {
            self.tables.get(name.as_str())
        }

  code_quality_tools:
    essential:
      cargo_audit:
        purpose: "Check for security vulnerabilities in dependencies"
        install: "cargo install cargo-audit"
        run: "cargo audit"
        ci: "Run in GitHub Actions on every PR"

      cargo_deny:
        purpose: "Policy enforcement for deps (licenses, security, duplicates)"
        install: "cargo install cargo-deny"
        setup: "cargo deny init"
        run: "cargo deny check"
        checks:
          - "License compatibility"
          - "Security advisories"
          - "Duplicate dependencies"
          - "Banned crates"

      cargo_machete:
        purpose: "Find unused dependencies"
        install: "cargo install cargo-machete"
        run: "cargo machete"
        why: "Faster builds, smaller binaries, less attack surface"

      cargo_nextest:
        purpose: "Faster test runner (parallel by default)"
        install: "cargo install cargo-nextest"
        run: "cargo nextest run"
        benefits:
          - "Cleaner output"
          - "Faster execution"
          - "Better CI integration"
          - "Flaky test detection"

    advanced:
      miri:
        purpose: "Detect undefined behavior (use-after-free, data races)"
        install: "rustup component add miri"
        run: "cargo miri test"
        when: "Testing unsafe code or complex concurrency"

      cargo_tarpaulin:
        purpose: "Code coverage analysis"
        install: "cargo install cargo-tarpaulin"
        run: "cargo tarpaulin --out Html"
        goal: "Aim for >80% coverage, 100% on critical paths"

  documentation_best_practices:
    humor_and_clarity:
      philosophy: "Make docs memorable and fun while staying professional"
      why: "People remember stories better than specs. Humor reduces intimidation."

      guidelines:
        do:
          - "Use relatable metaphors and analogies"
          - "Add playful examples (rubber ducks, pizza, cats)"
          - "Self-deprecating humor about common mistakes"
          - "Pop culture references (when widely known)"
          - "Celebrate small wins with enthusiasm"
          - "Use emojis sparingly but effectively (üéâ üêõ üöÄ)"

        dont:
          - "No offensive jokes (politics, religion, demographics)"
          - "No inside jokes that exclude newcomers"
          - "No sarcasm that could confuse (tone is hard in text)"
          - "No jokes at user's expense"
          - "No humor in error messages (user is frustrated!)"

      metaphors_for_common_concepts:
        ownership_and_borrowing: |
          // Ownership is like car keys
          let keys = CarKeys::new();  // You own the keys
          drive_car(&keys);           // Lend keys temporarily (borrow)
          // Keys automatically returned after function
          // Can't lose keys while someone's borrowing them!

        option_vs_result: |
          // Option: Schr√∂dinger's cat üê±
          //   Some(cat) = cat is alive!
          //   None = box is empty, no cat

          // Result: Cat delivery service üì¶
          //   Ok(cat) = cat delivered successfully!
          //   Err(e) = delivery failed (stuck in tree, wrong address, etc.)

        iterators: |
          // Iterators are like assembly lines
          vec.iter()              // Put items on conveyor belt
             .filter(|x| x > 10)  // Quality control station
             .map(|x| x * 2)      // Processing station
             .collect()           // Package at end of line

        closures: |
          // Closures are like food trucks
          let pizza_truck = |toppings| {
              make_pizza(toppings)  // Captures make_pizza from environment
          };
          // Food truck can be called anywhere, brings its equipment!

        trait_objects: |
          // Trait objects are like power outlets
          // Don't care if it's a phone, laptop, or toaster
          // As long as it implements the "can plug in" trait!
          fn charge(device: &dyn Chargeable) {
              device.charge();  // Works for any chargeable device
          }

      example_doc_comments:
        boring: |
          /// Parses a YAML file and returns a ParsedModel.
          pub fn parse_model(path: &Path) -> ForgeResult<ParsedModel>

        with_personality: |
          /// Parses a YAML file into a delicious `ParsedModel` sandwich ü•™
          ///
          /// Think of this as your YAML ‚Üí Rust translator. Reads the YAML,
          /// checks if it's the new hotness (v1.0.0 arrays) or the classic
          /// recipe (v0.2.0 scalars), and serves it up in a type-safe wrapper.
          ///
          /// # Examples
          ///
          /// ```no_run
          /// // Feed it a YAML file, get back a structured model
          /// let model = parse_model(Path::new("quarterly_financials.yaml"))?;
          ///
          /// // Now you can work with typed data instead of raw strings!
          /// assert_eq!(model.version, ForgeVersion::V1_0_0);
          /// ```
          ///
          /// # Errors
          ///
          /// This function is a bit picky (in a good way!):
          /// - If the YAML is malformed, it'll let you know immediately
          /// - If arrays have mixed types, it'll stop you before bad things happen
          /// - If columns have different lengths, it'll save you from Excel export sadness
          ///
          /// Think of errors as your friendly neighborhood validator ü¶∏
          pub fn parse_model(path: &Path) -> ForgeResult<ParsedModel>

      README_personality_examples:
        technical_but_fun: |
          ## Why Forge?

          Because AI hallucinates, and your CFO doesn't appreciate creative accounting. üìä

          Forge is like a spell-checker for your financial formulas. It won't let you
          ship a model where `revenue - expenses = unicorns`. (We tried. It didn't work.)

          **Problem:** You have 1,140 formulas in your financial model. Excel says they're
          all fine. Excel is lying. ü§•

          **Solution:** Forge validates EVERY formula BEFORE you send it to investors.
          No more "Oops, we accidentally calculated our valuation in dog years."

        feature_descriptions: |
          ## Features That Spark Joy ‚ú®

          ### üéØ Excel-Compatible Formulas
          All your favorite hits: SUM, AVERAGE, IF, and friends. They work exactly
          like Excel, minus the existential dread of `#REF!` errors.

          ### üîí Type-Safe Arrays
          Forge won't let you mix numbers with text. Because `["Q1", 42, true]` is
          not a valid dataset, it's a cry for help.

          ### ‚ö° Blazingly Fast‚Ñ¢
          Validates 1,140 formulas in <200ms. That's faster than Excel can say
          "Not Responding" on your coworker's laptop.

          ### üìê Zero Error Tolerance
          Your model either works perfectly or tells you exactly what's wrong.
          No "works on my machine" shenanigans.

      error_message_guidelines:
        important_note: "Error messages should be HELPFUL, not funny. User is already frustrated!"

        error_message_structure: |
          // Structure: What went wrong + Why + How to fix
          ForgeError::Parse(format!(
              "Column '{}' has mixed types (found Number and Text). \n\
               All values in an array must be the same type for Excel export. \n\
               Tip: Use separate columns for different data types.",
              column_name
          ))

        do_in_errors:
          - "Be specific about what went wrong"
          - "Explain why it's a problem"
          - "Suggest how to fix it"
          - "Show the problematic value if helpful"
          - "Use friendly language ('Tip:', 'Note:')"

        dont_in_errors:
          - "Don't use humor or sarcasm"
          - "Don't blame the user ('you did X wrong')"
          - "Don't use jargon without explanation"
          - "Don't just say 'invalid input' - be specific!"

      comments_in_code:
        good_comments: |
          // Why xlformula_engine uses f32: Excel's native number format
          // We round to 6 decimals to avoid issues like 0.9 showing as 0.8999999
          // This is a reasonable tradeoff for financial calculations (max error: ¬±0.0001%)

          // TODO: Implement SUMIF after basic aggregation works
          // (Don't want to run before we can walk!)

          // HACK: xlformula_engine doesn't understand @ for cross-file refs
          // So we temporarily replace @ with _ and convert back in resolver
          // It's like using a fake mustache to sneak past a bouncer ü•∏

        bad_comments: |
          // This is bad
          let x = 5;

          // Loop through items (duh, I can read the code!)
          for item in items {

          // Magic number (WHY?! What does 42 represent?)
          if count > 42 {

      git_commit_messages_with_personality:
        boring: "Fix bug in parser"

        better: "Fix parser crash on empty arrays"

        best: |
          Fix parser panic when encountering empty column arrays

          The parser was assuming all arrays had at least one element (rookie
          mistake!). This caused a panic when users had placeholder columns.

          Now we check for empty arrays and return a helpful error instead of
          crashing like a Windows 95 screensaver.

          Added test: test_empty_array_error

          ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>

    rustdoc:
      principles:
        - "Every public item should have doc comment (with personality!)"
        - "Start with one-line summary, then tell a story"
        - "Include examples in doc comments (they're tested!)"
        - "Use /// for items, //! for modules"
        - "Link to related items with [Type]"
        - "Add metaphors and analogies for complex concepts"
        - "Celebrate what the code does well"

      example: |
        /// Calculates all formulas in a v1.0.0 array model.
        ///
        /// This calculator handles row-wise (element-wise) operations on column arrays,
        /// with automatic dependency resolution within tables.
        ///
        /// # Examples
        ///
        /// ```no_run
        /// use royalbit_forge::core::ArrayCalculator;
        /// use royalbit_forge::parser::parse_model;
        /// use std::path::Path;
        ///
        /// let model = parse_model(Path::new("model.yaml"))?;
        /// let calculator = ArrayCalculator::new(model);
        /// let result = calculator.calculate_all()?;
        /// # Ok::<(), royalbit_forge::error::ForgeError>(())
        /// ```
        ///
        /// # Errors
        ///
        /// Returns [`ForgeError::Eval`] if formula evaluation fails.
        /// Returns [`ForgeError::CircularDependency`] if circular refs detected.
        pub fn calculate_all(mut self) -> ForgeResult<ParsedModel> {
            // ...
        }

      check: "cargo doc --no-deps --open"

    architecture_decision_records:
      description: "Document significant architectural decisions"
      format: "ADRs in docs/adr/ directory"

      template: |
        # ADR-001: Use xlformula_engine for Excel Compatibility

        ## Status
        Accepted (2025-11-23)

        ## Context
        Need Excel-compatible formula evaluation for v0.2.0.
        Options: meval (simple), evalexpr, xlformula_engine.

        ## Decision
        Use xlformula_engine despite f32 precision concerns.

        ## Consequences
        + Excel compatibility
        + Rich formula library
        - f32 precision (mitigated with rounding)
        - External dependency maintenance

      when_to_write:
        - "Major library choices"
        - "Architectural patterns"
        - "Breaking changes"
        - "Performance trade-offs"

tips_for_success:
  critical:
    - "üö® CHECK CURRENT DATE in <env> before ANY online search!"
    - "ZERO warnings policy - treat warnings as errors (user has OCD for clean code üòä)"
    - "Run cargo audit before releases (no surprises from dependency CVEs)"

  planning:
    - "Think harder before implementing - measure twice, code once üìê"
    - "BEFORE complex code: Search crates.io (don't reinvent the wheel, it's already round)"
    - "Profile before optimizing - premature optimization is the root of all evil (and wasted time)"
    - "Read DESIGN_V1.md - comprehensive design docs exist for a reason!"

  testing:
    - "Write tests first when possible (TDD = sleep better at night)"
    - "Test edge cases - empty arrays, nulls, invalid inputs (Murphy's Law is undefeated)"
    - "Consider property-based testing for complex logic (test the rules, not examples)"
    - "If a bug makes it to production, write a test so it never comes back (revenge testing!)"

  type_safety:
    - "Use type system to prevent bugs (make illegal states unrepresentable)"
    - "Newtypes are your friends (TableName ‚â† ColumnName, even though both are strings)"
    - "Enums over booleans (states > true/false)"
    - "Builder pattern for complex construction (fluent APIs are a joy to use)"

  code_quality:
    - "Run clippy frequently (it's like having a pedantic friend who's always right)"
    - "cargo fmt before every commit (consistency = readability)"
    - "No unwrap() in library code (Result<T,E> or bust)"
    - "Comments should explain WHY, not WHAT (code shows what, you explain why)"

  documentation:
    - "Update docs as you code, not after (future you will thank present you)"
    - "Add personality to docs - make them memorable (car keys, food trucks, cats üê±)"
    - "Examples in rustdoc are tested (free test coverage!)"
    - "Error messages: helpful, not funny (user is frustrated, not entertained)"

  workflow:
    - "Commit frequently with descriptive messages (tell a story, not a changelog)"
    - "Use TodoWrite to track progress (Claude's memory needs help)"
    - "Check KNOWN_BUGS.md before fixing (might already be documented)"
    - "One feature per commit (atomic changes = easy reverts)"

  collaboration:
    - "Ask user for clarification on ambiguous requirements (assumptions are dangerous)"
    - "Check license compatibility (MIT-compatible only, GPL is the Voldemort of licenses)"
    - "When stuck, explain the problem out loud (rubber duck debugging works!)"

  wisdom:
    - "If it compiles in Rust, it probably works (type system FTW)"
    - "If tests pass but feel fragile, trust your instincts"
    - "Simpler code > clever code (cleverness is hard to debug at 2am)"
    - "When in doubt, add a test (tests never lie)"
    - "Break before optimize, fix before enhance, test before merge"

collaboration_notes:
  user_preferences:
    - "User values: zero errors, 100% accuracy, thorough testing"
    - "User has OCD for beautiful code - ZERO warnings, strict linting"
    - "User says 'Punch it!' when ready to proceed"
    - "User says 'Think harder' when wanting deeper analysis"
    - "User provides context from previous sessions via summary"
    - "Always check current date before online searches (training data is old!)"

session_end_checklist:
  description: "MANDATORY before ending ANY session - ensures pristine state"
  philosophy: |
    We ALWAYS end sessions with pristine code.
    This means next session can ASSUME clean state (no redundant verification).
    NEVER end a session with failing tests, linting errors, or uncommitted changes.

  code_quality:
    - "‚òê cargo test --release ‚Üí ALL passing, ZERO ignored"
    - "‚òê cargo clippy --release -- -D warnings ‚Üí ZERO warnings"
    - "‚òê cargo fmt -- --check ‚Üí No formatting changes needed"
    - "‚òê cargo build --release ‚Üí ZERO warnings, ZERO errors"

  documentation_quality:
    - "‚òê make validate-docs ‚Üí ZERO markdown errors"
    - "‚òê make validate-yaml ‚Üí ZERO YAML errors"
    - "‚òê README.md reflects current features"
    - "‚òê CHANGELOG.md updated for any changes"
    - "‚òê Docs updated in SAME commit as code changes"

  git_state:
    - "‚òê All changes committed (no uncommitted files)"
    - "‚òê Commit message follows format"
    - "‚òê Changes pushed to remote"
    - "‚òê Working directory is CLEAN (git status shows nothing)"

  project_state:
    - "‚òê Roadmap updated if progress changed"
    - "‚òê Schema updated if model changed"
    - "‚òê OpenAPI spec updated if API changed"
    - "‚òê User knows current status and next steps"

  sred_and_grants:
    description: "üí∞ This documentation = real money in tax credits and grants"
    checklist:
      - "‚òê üçÅ SR&ED log updated if R&D work was done (docs/internal/SRED_RESEARCH_LOG.md)"
      - "‚òê Grant docs updated if capabilities changed (docs/CANADIAN_GRANT_OPPORTUNITIES.md)"

  time_tracking:
    description: "üìä Track AI development hours - backs up 'Built by AI in X hours'"
    checklist:
      - "‚òê Calculate session duration (end time - start time)"
      - "‚òê Log session to docs/internal/AI_DEVELOPMENT_HOURS.md"
      - "‚òê Update total hours count"
      - "‚òê Cross-reference with git log if significant session"
      - "‚òê Announce: 'Session duration: X hours (Total: Y hours)'"

  enforcement: "Do NOT end session until ALL boxes are checked"

grant_opportunities:
  description: "Canadian grant funding for Forge + Warmup Protocol innovation"

  ‚ö†Ô∏è_IMPORTANT: |
    Grant programs, deadlines, eligibility, and funding amounts CHANGE FREQUENTLY.
    This section provides CATEGORIES of grants to research, NOT current information.
    ALWAYS verify current status via web search before any application.

  research_protocol:
    before_any_application:
      - "Web search: '[grant name] [current year] eligibility deadline'"
      - "Check official government/organization websites"
      - "Verify program still exists (programs are discontinued regularly)"
      - "Confirm current funding amounts (budgets change yearly)"
      - "Check application windows (many have narrow windows)"
    documentation_to_keep_updated:
      primary: "docs/CANADIAN_GRANT_OPPORTUNITIES.md"
      research: "docs/GRANT_RESEARCH_[DATE].md (create fresh before applications)"
      sred_log: "SRED_RESEARCH_LOG.md (update after every experiment)"

  company_status:
    structure: "Woman-owned Canadian corporation"
    location: "Montreal, Quebec, Canada"
    qualification: "Triple advantage: Technology innovation + Woman-owned + Quebec location"

  grant_categories:
    note: "These are CATEGORIES to research. Verify current programs, dates, and amounts before applying."

    tier_1_federal_rd:
      irap:
        name: "NRC IRAP (Industrial Research Assistance Program)"
        typical_value: "$300K-$500K (verify current limits)"
        typical_coverage: "~80% salaries, ~50% contractors (non-repayable)"
        contact: "1-877-994-4727"
        research: "Search 'NRC IRAP [current year] eligibility'"
        why: "Perfect fit for autonomous AI protocol R&D"

      sred:
        name: "SR&ED Tax Credits (Federal + Quebec)"
        typical_value: "$130K+/year (refundable, rates change)"
        typical_coverage: "Federal ~35% + Quebec ~30% of R&D costs"
        timeline: "File with annual tax return"
        status: "Document experiments in SRED_RESEARCH_LOG.md"
        research: "Search 'SR&ED [current year] rates eligibility'"

      ai_compute_programs:
        description: "Federal AI compute/cloud funding programs"
        research: "Search 'Canada AI compute fund [current year]'"
        why: "Warmup Protocol is AI methodology innovation"

    tier_2_woman_owned:
      description: "Programs specifically for woman-owned businesses"
      research_queries:
        - "'Canadian women entrepreneur grants [current year]'"
        - "'woman-owned business grants Quebec [current year]'"
        - "'BMO women grants [current year]' (check if program exists)"
        - "'women in tech grants Canada [current year]'"
      typical_programs:
        - "Bank-sponsored women entrepreneur grants (BMO, RBC, TD, etc.)"
        - "Foundation grants (Bombardier, etc.)"
        - "Provincial women entrepreneur programs"
        - "Femmessor Quebec (or successor programs)"
      eligibility_notes:
        - "Typically require 51%+ women ownership"
        - "Some accept 25%+ women ownership"
        - "Application windows are often VERY narrow (days, not weeks)"

    tier_3_quebec_montreal:
      description: "Provincial and municipal innovation programs"
      research_queries:
        - "'Quebec AI innovation grants [current year]'"
        - "'PROMPT Quebec [current year]'"
        - "'Montreal innovation fund [current year]'"
        - "'PME MTL grants [current year]'"
        - "'Quebec technology grants [current year]'"
      typical_programs:
        - "PROMPT AI Programs (Quebec AI innovation)"
        - "PSO (Support Program for Research and Innovation)"
        - "Montreal Innovation Fund"
        - "PME MTL Programs"
      eligibility_notes:
        - "Quebec location required"
        - "Some require Montreal HQ specifically"
        - "Often have sector-specific requirements"

  key_advantages:
    technological_innovation:
      forge: "YAML formula calculator with Excel bridge (solves $40K-$132K/year AI hallucination costs)"
      warmup_protocol: "World's first autonomous AI development methodology (3-4x velocity, 0% rework)"
      validation: "See AI_DEVELOPMENT_HOURS.md for actual hours, cargo test for test count"

    woman_owned_business:
      status: "Woman-owned Canadian corporation"
      qualification: "Meets woman-owned criteria for most women entrepreneur programs"
      additional_streams: "Access to woman entrepreneur grants across federal, provincial, municipal"

    quebec_location:
      advantage: "Access to federal + provincial + municipal programs"
      typical_programs: "PROMPT, PSO, Montreal Innovation Fund, PME MTL, IRAP, SR&ED"

    open_source_foss:
      license: "MIT (open source)"
      publication: "Published on crates.io (Rust package registry)"
      benefit: "Demonstrates broader community impact for grant applications"

    proven_results:
      production: "Grant funding protected from AI hallucinations"
      quality: "ZERO bugs shipped, comprehensive test coverage, ZERO warnings"
      velocity: "3-4x development speed, 0% rework (vs industry 30-50%)"
      documentation: "Comprehensive SR&ED research log with documented experiments"

  action_protocol:
    quarterly_research:
      - "Search for new grant programs (programs launch/end throughout year)"
      - "Verify existing programs still exist"
      - "Check upcoming application windows"
      - "Update docs/CANADIAN_GRANT_OPPORTUNITIES.md with findings"

    before_applications:
      - "Create fresh docs/GRANT_RESEARCH_[DATE].md with web search results"
      - "Verify all deadlines from official sources"
      - "Prepare company documents (incorporation, ownership proof)"
      - "Update metrics in application materials"

    ongoing:
      - "Continue SR&ED research log (document ALL experiments)"
      - "Track AI development hours for proof"
      - "Maintain comprehensive git history"

  selling_points:
    elevator_pitch: |
      RoyalBit Inc. has developed two Canadian technological breakthroughs:

      1. Forge: Open-source YAML formula calculator solving $40K-$132K/year AI hallucination costs
      2. Warmup Protocol: World's first autonomous AI development methodology (3-4x velocity, 0% rework)

      Woman-owned, Montreal-based, open source (MIT), production-proven, fully documented.

      This isn't incremental improvement. This is paradigm shift from 'AI assists developer' to 'AI IS developer.'

    quantifiable_results:
      velocity: "20-50x faster than traditional (conservative: 3-4x)"
      quality: "ZERO warnings, comprehensive test coverage, 0 bugs shipped"
      rework: "0% (vs. industry standard 30-50%)"
      cost_savings: "$40K-$132K/year for enterprise users"
      efficiency: "97% reduction in human oversight time"
      time_to_market: "Weeks instead of months"

  notes:
    - "‚ö†Ô∏è ALWAYS verify program status before applying - programs change/end frequently"
    - "Woman-owned status opens significant additional grant streams"
    - "Quebec location provides triple access: federal + provincial + municipal"
    - "Open source publication strengthens 'advancement of knowledge' criterion for SR&ED"
    - "Warmup Protocol represents genuine technological breakthrough (not just tool development)"
    - "Total potential varies by year - research current programs for estimates"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# RECOMMENDATIONS FOR FUTURE IMPROVEMENTS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

future_improvements:
  description: "Recommendations to evolve warmup.yaml and roadmap.yaml over time"

  warmup_protocol_improvements:
    quick_reference_section:
      priority: "HIGH"
      rationale: "Warmup is 2400+ lines - need TL;DR for returning sessions"
      implementation:
        - "Add 'quick_start' section at top with 20-line summary"
        - "List most critical rules: ZERO warnings, test coverage, time tracking"
        - "Link to detailed sections for deep dives"

    protocol_versioning:
      priority: "MEDIUM"
      rationale: "Track evolution of warmup protocol itself"
      implementation:
        - "Add version field (e.g., warmup_version: '2.0.0')"
        - "Add changelog section for significant protocol changes"
        - "Consider semantic versioning for protocol itself"

    automated_metrics_gathering:
      priority: "HIGH"
      rationale: "Eliminate manual metric collection"
      implementation:
        - "Create bin/gather-metrics.sh script"
        - "Auto-collect: test count, line count, coverage, warnings"
        - "Output in format ready for README/grants"
        - "Run as part of release checklist"

    separate_release_checklist:
      priority: "MEDIUM"
      rationale: "Release process is complex enough for dedicated file"
      implementation:
        - "Create release-checklist.yaml with step-by-step guide"
        - "Include pre-release, release, post-release phases"
        - "Add automation hooks for common tasks"

    test_coverage_automation:
      priority: "HIGH"
      rationale: "Track actual coverage percentages"
      implementation:
        - "Integrate cargo-tarpaulin for coverage reports"
        - "Add coverage thresholds to CI/CD"
        - "Generate coverage badges for README"

  roadmap_improvements:
    github_integration:
      priority: "HIGH"
      rationale: "Roadmap should reflect actual work"
      implementation:
        - "Create GitHub milestones matching roadmap versions"
        - "Use GitHub Projects for visual tracking"
        - "Link roadmap items to issues/PRs"

    user_feedback_loop:
      priority: "HIGH"
      rationale: "Roadmap should reflect user needs"
      implementation:
        - "Add GitHub Discussions for feature requests"
        - "Survey users on Excel feature priorities"
        - "Track feature requests in issues with labels"

    excel_compatibility_matrix:
      priority: "HIGH"
      rationale: "Critical goal needs detailed tracking"
      implementation:
        - "Create docs/EXCEL_COMPATIBILITY.md"
        - "List all Excel functions with status (supported/planned/not-planned)"
        - "Track Excel features (pivot tables, charts, etc.) with roadmap links"
        - "Add test cases for each Excel function"

    dependency_upgrade_schedule:
      priority: "MEDIUM"
      rationale: "Proactive security and features"
      implementation:
        - "Schedule monthly dependency reviews"
        - "Track breaking changes in major deps"
        - "Test thoroughly after upgrades"

  ci_cd_improvements:
    github_actions:
      priority: "HIGH"
      rationale: "Automate quality gates"
      implementation:
        - "Create .github/workflows/ci.yml"
        - "Run all linting (clippy, fmt, markdownlint, yamllint)"
        - "Run all tests (unit, integration, e2e)"
        - "Fail on ANY warning"
        - "Auto-generate release notes"

    automated_releases:
      priority: "MEDIUM"
      rationale: "Reduce manual release steps"
      implementation:
        - "Auto-publish to crates.io on tag"
        - "Auto-create GitHub release"
        - "Auto-build binaries for multiple platforms"

  documentation_improvements:
    openapi_automation:
      priority: "HIGH"
      rationale: "API docs should auto-generate"
      implementation:
        - "Create openapi.yaml for API server"
        - "Auto-generate from code annotations (utoipa crate)"
        - "Host Swagger UI at /api/docs"
        - "Generate client SDKs (Python, JS, etc.)"

    architecture_diagrams:
      priority: "MEDIUM"
      rationale: "Visual docs aid understanding"
      implementation:
        - "Keep Mermaid diagrams in markdown (GitHub renders them)"
        - "Auto-generate dependency graphs"
        - "Add sequence diagrams for complex flows"

    changelog_automation:
      priority: "MEDIUM"
      rationale: "Changelog should auto-generate from commits"
      implementation:
        - "Use conventional commits format"
        - "Auto-generate CHANGELOG.md from git history"
        - "Include in release process"

  community_growth:
    contribution_guidelines:
      priority: "LOW (for now)"
      rationale: "Prepare for community contributions"
      implementation:
        - "Create CONTRIBUTING.md"
        - "Define coding standards (reference warmup)"
        - "Set up issue templates"
        - "Define PR review process"

    documentation_i18n:
      priority: "LOW"
      rationale: "Reach non-English users"
      implementation:
        - "French documentation (Quebec market)"
        - "Other languages based on user base"

  immediate_actions:
    next_session:
      - "Create docs/EXCEL_COMPATIBILITY.md matrix"
      - "Create openapi.yaml for API server"
      - "Update JSON Schema to v2.0.0"
      - "Set up basic GitHub Actions CI"

    next_release:
      - "Add automated metrics gathering script"
      - "Create quick_start section in warmup.yaml"
      - "Add coverage tracking with cargo-tarpaulin"

  meta:
    last_reviewed: "Update this date when reviewing recommendations"
    review_frequency: "Review quarterly or after major releases"
